// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_message_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_message_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_message_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_message_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_message_2eproto;
namespace message {
class Character;
struct CharacterDefaultTypeInternal;
extern CharacterDefaultTypeInternal _Character_default_instance_;
class HelloMessage;
struct HelloMessageDefaultTypeInternal;
extern HelloMessageDefaultTypeInternal _HelloMessage_default_instance_;
class IntegerMessage;
struct IntegerMessageDefaultTypeInternal;
extern IntegerMessageDefaultTypeInternal _IntegerMessage_default_instance_;
class LobbyMessage;
struct LobbyMessageDefaultTypeInternal;
extern LobbyMessageDefaultTypeInternal _LobbyMessage_default_instance_;
class MessageWrapper;
struct MessageWrapperDefaultTypeInternal;
extern MessageWrapperDefaultTypeInternal _MessageWrapper_default_instance_;
class PlayerBasicMessage;
struct PlayerBasicMessageDefaultTypeInternal;
extern PlayerBasicMessageDefaultTypeInternal _PlayerBasicMessage_default_instance_;
class PropGetMessage;
struct PropGetMessageDefaultTypeInternal;
extern PropGetMessageDefaultTypeInternal _PropGetMessage_default_instance_;
class PropTryGetMessage;
struct PropTryGetMessageDefaultTypeInternal;
extern PropTryGetMessageDefaultTypeInternal _PropTryGetMessage_default_instance_;
class ReaperAttackMessage;
struct ReaperAttackMessageDefaultTypeInternal;
extern ReaperAttackMessageDefaultTypeInternal _ReaperAttackMessage_default_instance_;
class ReaperAttackResultMessage;
struct ReaperAttackResultMessageDefaultTypeInternal;
extern ReaperAttackResultMessageDefaultTypeInternal _ReaperAttackResultMessage_default_instance_;
class RoomMessage;
struct RoomMessageDefaultTypeInternal;
extern RoomMessageDefaultTypeInternal _RoomMessage_default_instance_;
class SoulStateMessage;
struct SoulStateMessageDefaultTypeInternal;
extern SoulStateMessageDefaultTypeInternal _SoulStateMessage_default_instance_;
class StartReceiveMsgMessage;
struct StartReceiveMsgMessageDefaultTypeInternal;
extern StartReceiveMsgMessageDefaultTypeInternal _StartReceiveMsgMessage_default_instance_;
class StringMessage;
struct StringMessageDefaultTypeInternal;
extern StringMessageDefaultTypeInternal _StringMessage_default_instance_;
}  // namespace message
PROTOBUF_NAMESPACE_OPEN
template<> ::message::Character* Arena::CreateMaybeMessage<::message::Character>(Arena*);
template<> ::message::HelloMessage* Arena::CreateMaybeMessage<::message::HelloMessage>(Arena*);
template<> ::message::IntegerMessage* Arena::CreateMaybeMessage<::message::IntegerMessage>(Arena*);
template<> ::message::LobbyMessage* Arena::CreateMaybeMessage<::message::LobbyMessage>(Arena*);
template<> ::message::MessageWrapper* Arena::CreateMaybeMessage<::message::MessageWrapper>(Arena*);
template<> ::message::PlayerBasicMessage* Arena::CreateMaybeMessage<::message::PlayerBasicMessage>(Arena*);
template<> ::message::PropGetMessage* Arena::CreateMaybeMessage<::message::PropGetMessage>(Arena*);
template<> ::message::PropTryGetMessage* Arena::CreateMaybeMessage<::message::PropTryGetMessage>(Arena*);
template<> ::message::ReaperAttackMessage* Arena::CreateMaybeMessage<::message::ReaperAttackMessage>(Arena*);
template<> ::message::ReaperAttackResultMessage* Arena::CreateMaybeMessage<::message::ReaperAttackResultMessage>(Arena*);
template<> ::message::RoomMessage* Arena::CreateMaybeMessage<::message::RoomMessage>(Arena*);
template<> ::message::SoulStateMessage* Arena::CreateMaybeMessage<::message::SoulStateMessage>(Arena*);
template<> ::message::StartReceiveMsgMessage* Arena::CreateMaybeMessage<::message::StartReceiveMsgMessage>(Arena*);
template<> ::message::StringMessage* Arena::CreateMaybeMessage<::message::StringMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace message {

enum CharacterType : int {
  REAPER = 0,
  SOUL_DOG = 1,
  SOUL_PSYCHOLOGIST = 2,
  SOUL_DETECTIVE = 3,
  CharacterType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CharacterType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CharacterType_IsValid(int value);
constexpr CharacterType CharacterType_MIN = REAPER;
constexpr CharacterType CharacterType_MAX = SOUL_DETECTIVE;
constexpr int CharacterType_ARRAYSIZE = CharacterType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CharacterType_descriptor();
template<typename T>
inline const std::string& CharacterType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CharacterType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CharacterType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CharacterType_descriptor(), enum_t_value);
}
inline bool CharacterType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CharacterType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CharacterType>(
    CharacterType_descriptor(), name, value);
}
enum StringMessageType : int {
  MAZE_MAP = 0,
  StringMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StringMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StringMessageType_IsValid(int value);
constexpr StringMessageType StringMessageType_MIN = MAZE_MAP;
constexpr StringMessageType StringMessageType_MAX = MAZE_MAP;
constexpr int StringMessageType_ARRAYSIZE = StringMessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StringMessageType_descriptor();
template<typename T>
inline const std::string& StringMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StringMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StringMessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StringMessageType_descriptor(), enum_t_value);
}
inline bool StringMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StringMessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StringMessageType>(
    StringMessageType_descriptor(), name, value);
}
enum PlayerAnimationType : int {
  IDLE = 0,
  WALK_LEFT = 1,
  WALK_RIGHT = 2,
  DASH_LEFT = 3,
  DASH_RIGHT = 4,
  ATTACK = 5,
  HIT = 6,
  WEAK = 7,
  DIE = 8,
  PlayerAnimationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PlayerAnimationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PlayerAnimationType_IsValid(int value);
constexpr PlayerAnimationType PlayerAnimationType_MIN = IDLE;
constexpr PlayerAnimationType PlayerAnimationType_MAX = DIE;
constexpr int PlayerAnimationType_ARRAYSIZE = PlayerAnimationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayerAnimationType_descriptor();
template<typename T>
inline const std::string& PlayerAnimationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayerAnimationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayerAnimationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlayerAnimationType_descriptor(), enum_t_value);
}
inline bool PlayerAnimationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlayerAnimationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayerAnimationType>(
    PlayerAnimationType_descriptor(), name, value);
}
enum SoulState : int {
  SOUL_STATE_NORMAL = 0,
  SOUL_STATE_WEAK = 1,
  SOUL_STATE_DIE = 2,
  SoulState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SoulState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SoulState_IsValid(int value);
constexpr SoulState SoulState_MIN = SOUL_STATE_NORMAL;
constexpr SoulState SoulState_MAX = SOUL_STATE_DIE;
constexpr int SoulState_ARRAYSIZE = SoulState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SoulState_descriptor();
template<typename T>
inline const std::string& SoulState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SoulState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SoulState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SoulState_descriptor(), enum_t_value);
}
inline bool SoulState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SoulState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SoulState>(
    SoulState_descriptor(), name, value);
}
enum IntegerMessageType : int {
  ALTAR_MINI_GAME_SUCCESS = 0,
  IntegerMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IntegerMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IntegerMessageType_IsValid(int value);
constexpr IntegerMessageType IntegerMessageType_MIN = ALTAR_MINI_GAME_SUCCESS;
constexpr IntegerMessageType IntegerMessageType_MAX = ALTAR_MINI_GAME_SUCCESS;
constexpr int IntegerMessageType_ARRAYSIZE = IntegerMessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IntegerMessageType_descriptor();
template<typename T>
inline const std::string& IntegerMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IntegerMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IntegerMessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IntegerMessageType_descriptor(), enum_t_value);
}
inline bool IntegerMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IntegerMessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IntegerMessageType>(
    IntegerMessageType_descriptor(), name, value);
}
// ===================================================================

class HelloMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.HelloMessage) */ {
 public:
  inline HelloMessage() : HelloMessage(nullptr) {}
  ~HelloMessage() override;
  explicit constexpr HelloMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HelloMessage(const HelloMessage& from);
  HelloMessage(HelloMessage&& from) noexcept
    : HelloMessage() {
    *this = ::std::move(from);
  }

  inline HelloMessage& operator=(const HelloMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloMessage& operator=(HelloMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelloMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelloMessage* internal_default_instance() {
    return reinterpret_cast<const HelloMessage*>(
               &_HelloMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HelloMessage& a, HelloMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HelloMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HelloMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HelloMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HelloMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.HelloMessage";
  }
  protected:
  explicit HelloMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIdFieldNumber = 1,
  };
  // int32 room_id = 1;
  void clear_room_id();
  int32_t room_id() const;
  void set_room_id(int32_t value);
  private:
  int32_t _internal_room_id() const;
  void _internal_set_room_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.HelloMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t room_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class Character final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.Character) */ {
 public:
  inline Character() : Character(nullptr) {}
  ~Character() override;
  explicit constexpr Character(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Character(const Character& from);
  Character(Character&& from) noexcept
    : Character() {
    *this = ::std::move(from);
  }

  inline Character& operator=(const Character& from) {
    CopyFrom(from);
    return *this;
  }
  inline Character& operator=(Character&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Character& default_instance() {
    return *internal_default_instance();
  }
  static inline const Character* internal_default_instance() {
    return reinterpret_cast<const Character*>(
               &_Character_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Character& a, Character& b) {
    a.Swap(&b);
  }
  inline void Swap(Character* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Character* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Character* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Character>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Character& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Character& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Character* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.Character";
  }
  protected:
  explicit Character(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kCharacterTypeFieldNumber = 2,
  };
  // int32 player_id = 1;
  void clear_player_id();
  int32_t player_id() const;
  void set_player_id(int32_t value);
  private:
  int32_t _internal_player_id() const;
  void _internal_set_player_id(int32_t value);
  public:

  // .message.CharacterType character_type = 2;
  void clear_character_type();
  ::message::CharacterType character_type() const;
  void set_character_type(::message::CharacterType value);
  private:
  ::message::CharacterType _internal_character_type() const;
  void _internal_set_character_type(::message::CharacterType value);
  public:

  // @@protoc_insertion_point(class_scope:message.Character)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t player_id_;
  int character_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class MessageWrapper final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.MessageWrapper) */ {
 public:
  inline MessageWrapper() : MessageWrapper(nullptr) {}
  ~MessageWrapper() override;
  explicit constexpr MessageWrapper(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageWrapper(const MessageWrapper& from);
  MessageWrapper(MessageWrapper&& from) noexcept
    : MessageWrapper() {
    *this = ::std::move(from);
  }

  inline MessageWrapper& operator=(const MessageWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageWrapper& operator=(MessageWrapper&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageWrapper& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kRoomMessage = 1,
    kStringMessage = 2,
    kLobbyMessage = 3,
    kStartReceiveMsgMessage = 4,
    kPlayerBasicMessage = 5,
    kReaperAttackMessage = 6,
    kReaperAttackResultMessage = 7,
    kPropTryGetMessage = 8,
    kPropGetMessage = 9,
    kIntegerMessage = 10,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const MessageWrapper* internal_default_instance() {
    return reinterpret_cast<const MessageWrapper*>(
               &_MessageWrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MessageWrapper& a, MessageWrapper& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageWrapper* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageWrapper* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageWrapper* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageWrapper>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageWrapper& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MessageWrapper& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageWrapper* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.MessageWrapper";
  }
  protected:
  explicit MessageWrapper(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomMessageFieldNumber = 1,
    kStringMessageFieldNumber = 2,
    kLobbyMessageFieldNumber = 3,
    kStartReceiveMsgMessageFieldNumber = 4,
    kPlayerBasicMessageFieldNumber = 5,
    kReaperAttackMessageFieldNumber = 6,
    kReaperAttackResultMessageFieldNumber = 7,
    kPropTryGetMessageFieldNumber = 8,
    kPropGetMessageFieldNumber = 9,
    kIntegerMessageFieldNumber = 10,
  };
  // .message.RoomMessage room_message = 1;
  bool has_room_message() const;
  private:
  bool _internal_has_room_message() const;
  public:
  void clear_room_message();
  const ::message::RoomMessage& room_message() const;
  PROTOBUF_NODISCARD ::message::RoomMessage* release_room_message();
  ::message::RoomMessage* mutable_room_message();
  void set_allocated_room_message(::message::RoomMessage* room_message);
  private:
  const ::message::RoomMessage& _internal_room_message() const;
  ::message::RoomMessage* _internal_mutable_room_message();
  public:
  void unsafe_arena_set_allocated_room_message(
      ::message::RoomMessage* room_message);
  ::message::RoomMessage* unsafe_arena_release_room_message();

  // .message.StringMessage string_message = 2;
  bool has_string_message() const;
  private:
  bool _internal_has_string_message() const;
  public:
  void clear_string_message();
  const ::message::StringMessage& string_message() const;
  PROTOBUF_NODISCARD ::message::StringMessage* release_string_message();
  ::message::StringMessage* mutable_string_message();
  void set_allocated_string_message(::message::StringMessage* string_message);
  private:
  const ::message::StringMessage& _internal_string_message() const;
  ::message::StringMessage* _internal_mutable_string_message();
  public:
  void unsafe_arena_set_allocated_string_message(
      ::message::StringMessage* string_message);
  ::message::StringMessage* unsafe_arena_release_string_message();

  // .message.LobbyMessage lobby_message = 3;
  bool has_lobby_message() const;
  private:
  bool _internal_has_lobby_message() const;
  public:
  void clear_lobby_message();
  const ::message::LobbyMessage& lobby_message() const;
  PROTOBUF_NODISCARD ::message::LobbyMessage* release_lobby_message();
  ::message::LobbyMessage* mutable_lobby_message();
  void set_allocated_lobby_message(::message::LobbyMessage* lobby_message);
  private:
  const ::message::LobbyMessage& _internal_lobby_message() const;
  ::message::LobbyMessage* _internal_mutable_lobby_message();
  public:
  void unsafe_arena_set_allocated_lobby_message(
      ::message::LobbyMessage* lobby_message);
  ::message::LobbyMessage* unsafe_arena_release_lobby_message();

  // .message.StartReceiveMsgMessage start_receive_msg_message = 4;
  bool has_start_receive_msg_message() const;
  private:
  bool _internal_has_start_receive_msg_message() const;
  public:
  void clear_start_receive_msg_message();
  const ::message::StartReceiveMsgMessage& start_receive_msg_message() const;
  PROTOBUF_NODISCARD ::message::StartReceiveMsgMessage* release_start_receive_msg_message();
  ::message::StartReceiveMsgMessage* mutable_start_receive_msg_message();
  void set_allocated_start_receive_msg_message(::message::StartReceiveMsgMessage* start_receive_msg_message);
  private:
  const ::message::StartReceiveMsgMessage& _internal_start_receive_msg_message() const;
  ::message::StartReceiveMsgMessage* _internal_mutable_start_receive_msg_message();
  public:
  void unsafe_arena_set_allocated_start_receive_msg_message(
      ::message::StartReceiveMsgMessage* start_receive_msg_message);
  ::message::StartReceiveMsgMessage* unsafe_arena_release_start_receive_msg_message();

  // .message.PlayerBasicMessage player_basic_message = 5;
  bool has_player_basic_message() const;
  private:
  bool _internal_has_player_basic_message() const;
  public:
  void clear_player_basic_message();
  const ::message::PlayerBasicMessage& player_basic_message() const;
  PROTOBUF_NODISCARD ::message::PlayerBasicMessage* release_player_basic_message();
  ::message::PlayerBasicMessage* mutable_player_basic_message();
  void set_allocated_player_basic_message(::message::PlayerBasicMessage* player_basic_message);
  private:
  const ::message::PlayerBasicMessage& _internal_player_basic_message() const;
  ::message::PlayerBasicMessage* _internal_mutable_player_basic_message();
  public:
  void unsafe_arena_set_allocated_player_basic_message(
      ::message::PlayerBasicMessage* player_basic_message);
  ::message::PlayerBasicMessage* unsafe_arena_release_player_basic_message();

  // .message.ReaperAttackMessage reaper_attack_message = 6;
  bool has_reaper_attack_message() const;
  private:
  bool _internal_has_reaper_attack_message() const;
  public:
  void clear_reaper_attack_message();
  const ::message::ReaperAttackMessage& reaper_attack_message() const;
  PROTOBUF_NODISCARD ::message::ReaperAttackMessage* release_reaper_attack_message();
  ::message::ReaperAttackMessage* mutable_reaper_attack_message();
  void set_allocated_reaper_attack_message(::message::ReaperAttackMessage* reaper_attack_message);
  private:
  const ::message::ReaperAttackMessage& _internal_reaper_attack_message() const;
  ::message::ReaperAttackMessage* _internal_mutable_reaper_attack_message();
  public:
  void unsafe_arena_set_allocated_reaper_attack_message(
      ::message::ReaperAttackMessage* reaper_attack_message);
  ::message::ReaperAttackMessage* unsafe_arena_release_reaper_attack_message();

  // .message.ReaperAttackResultMessage reaper_attack_result_message = 7;
  bool has_reaper_attack_result_message() const;
  private:
  bool _internal_has_reaper_attack_result_message() const;
  public:
  void clear_reaper_attack_result_message();
  const ::message::ReaperAttackResultMessage& reaper_attack_result_message() const;
  PROTOBUF_NODISCARD ::message::ReaperAttackResultMessage* release_reaper_attack_result_message();
  ::message::ReaperAttackResultMessage* mutable_reaper_attack_result_message();
  void set_allocated_reaper_attack_result_message(::message::ReaperAttackResultMessage* reaper_attack_result_message);
  private:
  const ::message::ReaperAttackResultMessage& _internal_reaper_attack_result_message() const;
  ::message::ReaperAttackResultMessage* _internal_mutable_reaper_attack_result_message();
  public:
  void unsafe_arena_set_allocated_reaper_attack_result_message(
      ::message::ReaperAttackResultMessage* reaper_attack_result_message);
  ::message::ReaperAttackResultMessage* unsafe_arena_release_reaper_attack_result_message();

  // .message.PropTryGetMessage prop_try_get_message = 8;
  bool has_prop_try_get_message() const;
  private:
  bool _internal_has_prop_try_get_message() const;
  public:
  void clear_prop_try_get_message();
  const ::message::PropTryGetMessage& prop_try_get_message() const;
  PROTOBUF_NODISCARD ::message::PropTryGetMessage* release_prop_try_get_message();
  ::message::PropTryGetMessage* mutable_prop_try_get_message();
  void set_allocated_prop_try_get_message(::message::PropTryGetMessage* prop_try_get_message);
  private:
  const ::message::PropTryGetMessage& _internal_prop_try_get_message() const;
  ::message::PropTryGetMessage* _internal_mutable_prop_try_get_message();
  public:
  void unsafe_arena_set_allocated_prop_try_get_message(
      ::message::PropTryGetMessage* prop_try_get_message);
  ::message::PropTryGetMessage* unsafe_arena_release_prop_try_get_message();

  // .message.PropGetMessage prop_get_message = 9;
  bool has_prop_get_message() const;
  private:
  bool _internal_has_prop_get_message() const;
  public:
  void clear_prop_get_message();
  const ::message::PropGetMessage& prop_get_message() const;
  PROTOBUF_NODISCARD ::message::PropGetMessage* release_prop_get_message();
  ::message::PropGetMessage* mutable_prop_get_message();
  void set_allocated_prop_get_message(::message::PropGetMessage* prop_get_message);
  private:
  const ::message::PropGetMessage& _internal_prop_get_message() const;
  ::message::PropGetMessage* _internal_mutable_prop_get_message();
  public:
  void unsafe_arena_set_allocated_prop_get_message(
      ::message::PropGetMessage* prop_get_message);
  ::message::PropGetMessage* unsafe_arena_release_prop_get_message();

  // .message.IntegerMessage integer_message = 10;
  bool has_integer_message() const;
  private:
  bool _internal_has_integer_message() const;
  public:
  void clear_integer_message();
  const ::message::IntegerMessage& integer_message() const;
  PROTOBUF_NODISCARD ::message::IntegerMessage* release_integer_message();
  ::message::IntegerMessage* mutable_integer_message();
  void set_allocated_integer_message(::message::IntegerMessage* integer_message);
  private:
  const ::message::IntegerMessage& _internal_integer_message() const;
  ::message::IntegerMessage* _internal_mutable_integer_message();
  public:
  void unsafe_arena_set_allocated_integer_message(
      ::message::IntegerMessage* integer_message);
  ::message::IntegerMessage* unsafe_arena_release_integer_message();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:message.MessageWrapper)
 private:
  class _Internal;
  void set_has_room_message();
  void set_has_string_message();
  void set_has_lobby_message();
  void set_has_start_receive_msg_message();
  void set_has_player_basic_message();
  void set_has_reaper_attack_message();
  void set_has_reaper_attack_result_message();
  void set_has_prop_try_get_message();
  void set_has_prop_get_message();
  void set_has_integer_message();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union PayloadUnion {
    constexpr PayloadUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::message::RoomMessage* room_message_;
    ::message::StringMessage* string_message_;
    ::message::LobbyMessage* lobby_message_;
    ::message::StartReceiveMsgMessage* start_receive_msg_message_;
    ::message::PlayerBasicMessage* player_basic_message_;
    ::message::ReaperAttackMessage* reaper_attack_message_;
    ::message::ReaperAttackResultMessage* reaper_attack_result_message_;
    ::message::PropTryGetMessage* prop_try_get_message_;
    ::message::PropGetMessage* prop_get_message_;
    ::message::IntegerMessage* integer_message_;
  } payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class RoomMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.RoomMessage) */ {
 public:
  inline RoomMessage() : RoomMessage(nullptr) {}
  ~RoomMessage() override;
  explicit constexpr RoomMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomMessage(const RoomMessage& from);
  RoomMessage(RoomMessage&& from) noexcept
    : RoomMessage() {
    *this = ::std::move(from);
  }

  inline RoomMessage& operator=(const RoomMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomMessage& operator=(RoomMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomMessage* internal_default_instance() {
    return reinterpret_cast<const RoomMessage*>(
               &_RoomMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RoomMessage& a, RoomMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoomMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.RoomMessage";
  }
  protected:
  explicit RoomMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharactersFieldNumber = 4,
    kIsJoinFieldNumber = 1,
    kRoomIdFieldNumber = 2,
    kPlayerIdFieldNumber = 3,
  };
  // repeated .message.Character characters = 4;
  int characters_size() const;
  private:
  int _internal_characters_size() const;
  public:
  void clear_characters();
  ::message::Character* mutable_characters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::Character >*
      mutable_characters();
  private:
  const ::message::Character& _internal_characters(int index) const;
  ::message::Character* _internal_add_characters();
  public:
  const ::message::Character& characters(int index) const;
  ::message::Character* add_characters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::Character >&
      characters() const;

  // bool is_join = 1;
  void clear_is_join();
  bool is_join() const;
  void set_is_join(bool value);
  private:
  bool _internal_is_join() const;
  void _internal_set_is_join(bool value);
  public:

  // int32 room_id = 2;
  void clear_room_id();
  int32_t room_id() const;
  void set_room_id(int32_t value);
  private:
  int32_t _internal_room_id() const;
  void _internal_set_room_id(int32_t value);
  public:

  // int32 player_id = 3;
  void clear_player_id();
  int32_t player_id() const;
  void set_player_id(int32_t value);
  private:
  int32_t _internal_player_id() const;
  void _internal_set_player_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.RoomMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::Character > characters_;
  bool is_join_;
  int32_t room_id_;
  int32_t player_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class StringMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.StringMessage) */ {
 public:
  inline StringMessage() : StringMessage(nullptr) {}
  ~StringMessage() override;
  explicit constexpr StringMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StringMessage(const StringMessage& from);
  StringMessage(StringMessage&& from) noexcept
    : StringMessage() {
    *this = ::std::move(from);
  }

  inline StringMessage& operator=(const StringMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringMessage& operator=(StringMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringMessage* internal_default_instance() {
    return reinterpret_cast<const StringMessage*>(
               &_StringMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StringMessage& a, StringMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(StringMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StringMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StringMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.StringMessage";
  }
  protected:
  explicit StringMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageContentFieldNumber = 2,
    kMessageTypeFieldNumber = 1,
  };
  // string message_content = 2;
  void clear_message_content();
  const std::string& message_content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_content();
  PROTOBUF_NODISCARD std::string* release_message_content();
  void set_allocated_message_content(std::string* message_content);
  private:
  const std::string& _internal_message_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_content(const std::string& value);
  std::string* _internal_mutable_message_content();
  public:

  // int32 message_type = 1;
  void clear_message_type();
  int32_t message_type() const;
  void set_message_type(int32_t value);
  private:
  int32_t _internal_message_type() const;
  void _internal_set_message_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.StringMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_content_;
  int32_t message_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class LobbyMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.LobbyMessage) */ {
 public:
  inline LobbyMessage() : LobbyMessage(nullptr) {}
  ~LobbyMessage() override;
  explicit constexpr LobbyMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LobbyMessage(const LobbyMessage& from);
  LobbyMessage(LobbyMessage&& from) noexcept
    : LobbyMessage() {
    *this = ::std::move(from);
  }

  inline LobbyMessage& operator=(const LobbyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline LobbyMessage& operator=(LobbyMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LobbyMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const LobbyMessage* internal_default_instance() {
    return reinterpret_cast<const LobbyMessage*>(
               &_LobbyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LobbyMessage& a, LobbyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(LobbyMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LobbyMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LobbyMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LobbyMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LobbyMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LobbyMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LobbyMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.LobbyMessage";
  }
  protected:
  explicit LobbyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsReadyFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
    kCharacterTypeFieldNumber = 3,
  };
  // bool is_ready = 1;
  void clear_is_ready();
  bool is_ready() const;
  void set_is_ready(bool value);
  private:
  bool _internal_is_ready() const;
  void _internal_set_is_ready(bool value);
  public:

  // int32 player_id = 2;
  void clear_player_id();
  int32_t player_id() const;
  void set_player_id(int32_t value);
  private:
  int32_t _internal_player_id() const;
  void _internal_set_player_id(int32_t value);
  public:

  // .message.CharacterType character_type = 3;
  void clear_character_type();
  ::message::CharacterType character_type() const;
  void set_character_type(::message::CharacterType value);
  private:
  ::message::CharacterType _internal_character_type() const;
  void _internal_set_character_type(::message::CharacterType value);
  public:

  // @@protoc_insertion_point(class_scope:message.LobbyMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool is_ready_;
  int32_t player_id_;
  int character_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class StartReceiveMsgMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.StartReceiveMsgMessage) */ {
 public:
  inline StartReceiveMsgMessage() : StartReceiveMsgMessage(nullptr) {}
  ~StartReceiveMsgMessage() override;
  explicit constexpr StartReceiveMsgMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartReceiveMsgMessage(const StartReceiveMsgMessage& from);
  StartReceiveMsgMessage(StartReceiveMsgMessage&& from) noexcept
    : StartReceiveMsgMessage() {
    *this = ::std::move(from);
  }

  inline StartReceiveMsgMessage& operator=(const StartReceiveMsgMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartReceiveMsgMessage& operator=(StartReceiveMsgMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartReceiveMsgMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartReceiveMsgMessage* internal_default_instance() {
    return reinterpret_cast<const StartReceiveMsgMessage*>(
               &_StartReceiveMsgMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StartReceiveMsgMessage& a, StartReceiveMsgMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(StartReceiveMsgMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartReceiveMsgMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartReceiveMsgMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartReceiveMsgMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartReceiveMsgMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StartReceiveMsgMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartReceiveMsgMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.StartReceiveMsgMessage";
  }
  protected:
  explicit StartReceiveMsgMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // int32 player_id = 1;
  void clear_player_id();
  int32_t player_id() const;
  void set_player_id(int32_t value);
  private:
  int32_t _internal_player_id() const;
  void _internal_set_player_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.StartReceiveMsgMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t player_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class PlayerBasicMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.PlayerBasicMessage) */ {
 public:
  inline PlayerBasicMessage() : PlayerBasicMessage(nullptr) {}
  ~PlayerBasicMessage() override;
  explicit constexpr PlayerBasicMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerBasicMessage(const PlayerBasicMessage& from);
  PlayerBasicMessage(PlayerBasicMessage&& from) noexcept
    : PlayerBasicMessage() {
    *this = ::std::move(from);
  }

  inline PlayerBasicMessage& operator=(const PlayerBasicMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerBasicMessage& operator=(PlayerBasicMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerBasicMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerBasicMessage* internal_default_instance() {
    return reinterpret_cast<const PlayerBasicMessage*>(
               &_PlayerBasicMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PlayerBasicMessage& a, PlayerBasicMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerBasicMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerBasicMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerBasicMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerBasicMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerBasicMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerBasicMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerBasicMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.PlayerBasicMessage";
  }
  protected:
  explicit PlayerBasicMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kPositionXFieldNumber = 2,
    kPositionYFieldNumber = 3,
    kHpFieldNumber = 4,
    kMaxHpFieldNumber = 5,
    kAnimationTypeFieldNumber = 6,
  };
  // int32 player_id = 1;
  void clear_player_id();
  int32_t player_id() const;
  void set_player_id(int32_t value);
  private:
  int32_t _internal_player_id() const;
  void _internal_set_player_id(int32_t value);
  public:

  // float position_x = 2;
  void clear_position_x();
  float position_x() const;
  void set_position_x(float value);
  private:
  float _internal_position_x() const;
  void _internal_set_position_x(float value);
  public:

  // float position_y = 3;
  void clear_position_y();
  float position_y() const;
  void set_position_y(float value);
  private:
  float _internal_position_y() const;
  void _internal_set_position_y(float value);
  public:

  // float hp = 4;
  void clear_hp();
  float hp() const;
  void set_hp(float value);
  private:
  float _internal_hp() const;
  void _internal_set_hp(float value);
  public:

  // float max_hp = 5;
  void clear_max_hp();
  float max_hp() const;
  void set_max_hp(float value);
  private:
  float _internal_max_hp() const;
  void _internal_set_max_hp(float value);
  public:

  // .message.PlayerAnimationType animation_type = 6;
  void clear_animation_type();
  ::message::PlayerAnimationType animation_type() const;
  void set_animation_type(::message::PlayerAnimationType value);
  private:
  ::message::PlayerAnimationType _internal_animation_type() const;
  void _internal_set_animation_type(::message::PlayerAnimationType value);
  public:

  // @@protoc_insertion_point(class_scope:message.PlayerBasicMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t player_id_;
  float position_x_;
  float position_y_;
  float hp_;
  float max_hp_;
  int animation_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class SoulStateMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.SoulStateMessage) */ {
 public:
  inline SoulStateMessage() : SoulStateMessage(nullptr) {}
  ~SoulStateMessage() override;
  explicit constexpr SoulStateMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SoulStateMessage(const SoulStateMessage& from);
  SoulStateMessage(SoulStateMessage&& from) noexcept
    : SoulStateMessage() {
    *this = ::std::move(from);
  }

  inline SoulStateMessage& operator=(const SoulStateMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SoulStateMessage& operator=(SoulStateMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SoulStateMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SoulStateMessage* internal_default_instance() {
    return reinterpret_cast<const SoulStateMessage*>(
               &_SoulStateMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SoulStateMessage& a, SoulStateMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SoulStateMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SoulStateMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SoulStateMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SoulStateMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SoulStateMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SoulStateMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SoulStateMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.SoulStateMessage";
  }
  protected:
  explicit SoulStateMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSoulPlayerIdFieldNumber = 1,
    kSoulStateFieldNumber = 2,
  };
  // int32 soul_player_id = 1;
  void clear_soul_player_id();
  int32_t soul_player_id() const;
  void set_soul_player_id(int32_t value);
  private:
  int32_t _internal_soul_player_id() const;
  void _internal_set_soul_player_id(int32_t value);
  public:

  // .message.SoulState soul_state = 2;
  void clear_soul_state();
  ::message::SoulState soul_state() const;
  void set_soul_state(::message::SoulState value);
  private:
  ::message::SoulState _internal_soul_state() const;
  void _internal_set_soul_state(::message::SoulState value);
  public:

  // @@protoc_insertion_point(class_scope:message.SoulStateMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t soul_player_id_;
  int soul_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ReaperAttackMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.ReaperAttackMessage) */ {
 public:
  inline ReaperAttackMessage() : ReaperAttackMessage(nullptr) {}
  ~ReaperAttackMessage() override;
  explicit constexpr ReaperAttackMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReaperAttackMessage(const ReaperAttackMessage& from);
  ReaperAttackMessage(ReaperAttackMessage&& from) noexcept
    : ReaperAttackMessage() {
    *this = ::std::move(from);
  }

  inline ReaperAttackMessage& operator=(const ReaperAttackMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReaperAttackMessage& operator=(ReaperAttackMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReaperAttackMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReaperAttackMessage* internal_default_instance() {
    return reinterpret_cast<const ReaperAttackMessage*>(
               &_ReaperAttackMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ReaperAttackMessage& a, ReaperAttackMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ReaperAttackMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReaperAttackMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReaperAttackMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReaperAttackMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReaperAttackMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReaperAttackMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReaperAttackMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.ReaperAttackMessage";
  }
  protected:
  explicit ReaperAttackMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSoulPlayerIdFieldNumber = 1,
    kSkillIdFieldNumber = 2,
  };
  // int32 soul_player_id = 1;
  void clear_soul_player_id();
  int32_t soul_player_id() const;
  void set_soul_player_id(int32_t value);
  private:
  int32_t _internal_soul_player_id() const;
  void _internal_set_soul_player_id(int32_t value);
  public:

  // int32 skill_id = 2;
  void clear_skill_id();
  int32_t skill_id() const;
  void set_skill_id(int32_t value);
  private:
  int32_t _internal_skill_id() const;
  void _internal_set_skill_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.ReaperAttackMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t soul_player_id_;
  int32_t skill_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class PropTryGetMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.PropTryGetMessage) */ {
 public:
  inline PropTryGetMessage() : PropTryGetMessage(nullptr) {}
  ~PropTryGetMessage() override;
  explicit constexpr PropTryGetMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PropTryGetMessage(const PropTryGetMessage& from);
  PropTryGetMessage(PropTryGetMessage&& from) noexcept
    : PropTryGetMessage() {
    *this = ::std::move(from);
  }

  inline PropTryGetMessage& operator=(const PropTryGetMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PropTryGetMessage& operator=(PropTryGetMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PropTryGetMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PropTryGetMessage* internal_default_instance() {
    return reinterpret_cast<const PropTryGetMessage*>(
               &_PropTryGetMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PropTryGetMessage& a, PropTryGetMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PropTryGetMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PropTryGetMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PropTryGetMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PropTryGetMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PropTryGetMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PropTryGetMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PropTryGetMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.PropTryGetMessage";
  }
  protected:
  explicit PropTryGetMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kPropIdFieldNumber = 2,
    kPropTypeFieldNumber = 3,
  };
  // int32 player_id = 1;
  void clear_player_id();
  int32_t player_id() const;
  void set_player_id(int32_t value);
  private:
  int32_t _internal_player_id() const;
  void _internal_set_player_id(int32_t value);
  public:

  // int32 prop_id = 2;
  void clear_prop_id();
  int32_t prop_id() const;
  void set_prop_id(int32_t value);
  private:
  int32_t _internal_prop_id() const;
  void _internal_set_prop_id(int32_t value);
  public:

  // int32 prop_type = 3;
  void clear_prop_type();
  int32_t prop_type() const;
  void set_prop_type(int32_t value);
  private:
  int32_t _internal_prop_type() const;
  void _internal_set_prop_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.PropTryGetMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t player_id_;
  int32_t prop_id_;
  int32_t prop_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class PropGetMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.PropGetMessage) */ {
 public:
  inline PropGetMessage() : PropGetMessage(nullptr) {}
  ~PropGetMessage() override;
  explicit constexpr PropGetMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PropGetMessage(const PropGetMessage& from);
  PropGetMessage(PropGetMessage&& from) noexcept
    : PropGetMessage() {
    *this = ::std::move(from);
  }

  inline PropGetMessage& operator=(const PropGetMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PropGetMessage& operator=(PropGetMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PropGetMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PropGetMessage* internal_default_instance() {
    return reinterpret_cast<const PropGetMessage*>(
               &_PropGetMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(PropGetMessage& a, PropGetMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PropGetMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PropGetMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PropGetMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PropGetMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PropGetMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PropGetMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PropGetMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.PropGetMessage";
  }
  protected:
  explicit PropGetMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsGetFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
    kPropIdFieldNumber = 3,
  };
  // bool is_get = 1;
  void clear_is_get();
  bool is_get() const;
  void set_is_get(bool value);
  private:
  bool _internal_is_get() const;
  void _internal_set_is_get(bool value);
  public:

  // int32 player_id = 2;
  void clear_player_id();
  int32_t player_id() const;
  void set_player_id(int32_t value);
  private:
  int32_t _internal_player_id() const;
  void _internal_set_player_id(int32_t value);
  public:

  // int32 prop_id = 3;
  void clear_prop_id();
  int32_t prop_id() const;
  void set_prop_id(int32_t value);
  private:
  int32_t _internal_prop_id() const;
  void _internal_set_prop_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.PropGetMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool is_get_;
  int32_t player_id_;
  int32_t prop_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ReaperAttackResultMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.ReaperAttackResultMessage) */ {
 public:
  inline ReaperAttackResultMessage() : ReaperAttackResultMessage(nullptr) {}
  ~ReaperAttackResultMessage() override;
  explicit constexpr ReaperAttackResultMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReaperAttackResultMessage(const ReaperAttackResultMessage& from);
  ReaperAttackResultMessage(ReaperAttackResultMessage&& from) noexcept
    : ReaperAttackResultMessage() {
    *this = ::std::move(from);
  }

  inline ReaperAttackResultMessage& operator=(const ReaperAttackResultMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReaperAttackResultMessage& operator=(ReaperAttackResultMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReaperAttackResultMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReaperAttackResultMessage* internal_default_instance() {
    return reinterpret_cast<const ReaperAttackResultMessage*>(
               &_ReaperAttackResultMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ReaperAttackResultMessage& a, ReaperAttackResultMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ReaperAttackResultMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReaperAttackResultMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReaperAttackResultMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReaperAttackResultMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReaperAttackResultMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReaperAttackResultMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReaperAttackResultMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.ReaperAttackResultMessage";
  }
  protected:
  explicit ReaperAttackResultMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSoulPlayerIdFieldNumber = 1,
    kIsHitFieldNumber = 2,
  };
  // int32 soul_player_id = 1;
  void clear_soul_player_id();
  int32_t soul_player_id() const;
  void set_soul_player_id(int32_t value);
  private:
  int32_t _internal_soul_player_id() const;
  void _internal_set_soul_player_id(int32_t value);
  public:

  // bool is_hit = 2;
  void clear_is_hit();
  bool is_hit() const;
  void set_is_hit(bool value);
  private:
  bool _internal_is_hit() const;
  void _internal_set_is_hit(bool value);
  public:

  // @@protoc_insertion_point(class_scope:message.ReaperAttackResultMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t soul_player_id_;
  bool is_hit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class IntegerMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.IntegerMessage) */ {
 public:
  inline IntegerMessage() : IntegerMessage(nullptr) {}
  ~IntegerMessage() override;
  explicit constexpr IntegerMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntegerMessage(const IntegerMessage& from);
  IntegerMessage(IntegerMessage&& from) noexcept
    : IntegerMessage() {
    *this = ::std::move(from);
  }

  inline IntegerMessage& operator=(const IntegerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntegerMessage& operator=(IntegerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntegerMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntegerMessage* internal_default_instance() {
    return reinterpret_cast<const IntegerMessage*>(
               &_IntegerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(IntegerMessage& a, IntegerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(IntegerMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntegerMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntegerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntegerMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntegerMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IntegerMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntegerMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.IntegerMessage";
  }
  protected:
  explicit IntegerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageTypeFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // .message.IntegerMessageType message_type = 1;
  void clear_message_type();
  ::message::IntegerMessageType message_type() const;
  void set_message_type(::message::IntegerMessageType value);
  private:
  ::message::IntegerMessageType _internal_message_type() const;
  void _internal_set_message_type(::message::IntegerMessageType value);
  public:

  // int32 value = 2;
  void clear_value();
  int32_t value() const;
  void set_value(int32_t value);
  private:
  int32_t _internal_value() const;
  void _internal_set_value(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.IntegerMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int message_type_;
  int32_t value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HelloMessage

// int32 room_id = 1;
inline void HelloMessage::clear_room_id() {
  room_id_ = 0;
}
inline int32_t HelloMessage::_internal_room_id() const {
  return room_id_;
}
inline int32_t HelloMessage::room_id() const {
  // @@protoc_insertion_point(field_get:message.HelloMessage.room_id)
  return _internal_room_id();
}
inline void HelloMessage::_internal_set_room_id(int32_t value) {
  
  room_id_ = value;
}
inline void HelloMessage::set_room_id(int32_t value) {
  _internal_set_room_id(value);
  // @@protoc_insertion_point(field_set:message.HelloMessage.room_id)
}

// -------------------------------------------------------------------

// Character

// int32 player_id = 1;
inline void Character::clear_player_id() {
  player_id_ = 0;
}
inline int32_t Character::_internal_player_id() const {
  return player_id_;
}
inline int32_t Character::player_id() const {
  // @@protoc_insertion_point(field_get:message.Character.player_id)
  return _internal_player_id();
}
inline void Character::_internal_set_player_id(int32_t value) {
  
  player_id_ = value;
}
inline void Character::set_player_id(int32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:message.Character.player_id)
}

// .message.CharacterType character_type = 2;
inline void Character::clear_character_type() {
  character_type_ = 0;
}
inline ::message::CharacterType Character::_internal_character_type() const {
  return static_cast< ::message::CharacterType >(character_type_);
}
inline ::message::CharacterType Character::character_type() const {
  // @@protoc_insertion_point(field_get:message.Character.character_type)
  return _internal_character_type();
}
inline void Character::_internal_set_character_type(::message::CharacterType value) {
  
  character_type_ = value;
}
inline void Character::set_character_type(::message::CharacterType value) {
  _internal_set_character_type(value);
  // @@protoc_insertion_point(field_set:message.Character.character_type)
}

// -------------------------------------------------------------------

// MessageWrapper

// .message.RoomMessage room_message = 1;
inline bool MessageWrapper::_internal_has_room_message() const {
  return payload_case() == kRoomMessage;
}
inline bool MessageWrapper::has_room_message() const {
  return _internal_has_room_message();
}
inline void MessageWrapper::set_has_room_message() {
  _oneof_case_[0] = kRoomMessage;
}
inline void MessageWrapper::clear_room_message() {
  if (_internal_has_room_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.room_message_;
    }
    clear_has_payload();
  }
}
inline ::message::RoomMessage* MessageWrapper::release_room_message() {
  // @@protoc_insertion_point(field_release:message.MessageWrapper.room_message)
  if (_internal_has_room_message()) {
    clear_has_payload();
      ::message::RoomMessage* temp = payload_.room_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.room_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::RoomMessage& MessageWrapper::_internal_room_message() const {
  return _internal_has_room_message()
      ? *payload_.room_message_
      : reinterpret_cast< ::message::RoomMessage&>(::message::_RoomMessage_default_instance_);
}
inline const ::message::RoomMessage& MessageWrapper::room_message() const {
  // @@protoc_insertion_point(field_get:message.MessageWrapper.room_message)
  return _internal_room_message();
}
inline ::message::RoomMessage* MessageWrapper::unsafe_arena_release_room_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageWrapper.room_message)
  if (_internal_has_room_message()) {
    clear_has_payload();
    ::message::RoomMessage* temp = payload_.room_message_;
    payload_.room_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageWrapper::unsafe_arena_set_allocated_room_message(::message::RoomMessage* room_message) {
  clear_payload();
  if (room_message) {
    set_has_room_message();
    payload_.room_message_ = room_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageWrapper.room_message)
}
inline ::message::RoomMessage* MessageWrapper::_internal_mutable_room_message() {
  if (!_internal_has_room_message()) {
    clear_payload();
    set_has_room_message();
    payload_.room_message_ = CreateMaybeMessage< ::message::RoomMessage >(GetArenaForAllocation());
  }
  return payload_.room_message_;
}
inline ::message::RoomMessage* MessageWrapper::mutable_room_message() {
  ::message::RoomMessage* _msg = _internal_mutable_room_message();
  // @@protoc_insertion_point(field_mutable:message.MessageWrapper.room_message)
  return _msg;
}

// .message.StringMessage string_message = 2;
inline bool MessageWrapper::_internal_has_string_message() const {
  return payload_case() == kStringMessage;
}
inline bool MessageWrapper::has_string_message() const {
  return _internal_has_string_message();
}
inline void MessageWrapper::set_has_string_message() {
  _oneof_case_[0] = kStringMessage;
}
inline void MessageWrapper::clear_string_message() {
  if (_internal_has_string_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.string_message_;
    }
    clear_has_payload();
  }
}
inline ::message::StringMessage* MessageWrapper::release_string_message() {
  // @@protoc_insertion_point(field_release:message.MessageWrapper.string_message)
  if (_internal_has_string_message()) {
    clear_has_payload();
      ::message::StringMessage* temp = payload_.string_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.string_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::StringMessage& MessageWrapper::_internal_string_message() const {
  return _internal_has_string_message()
      ? *payload_.string_message_
      : reinterpret_cast< ::message::StringMessage&>(::message::_StringMessage_default_instance_);
}
inline const ::message::StringMessage& MessageWrapper::string_message() const {
  // @@protoc_insertion_point(field_get:message.MessageWrapper.string_message)
  return _internal_string_message();
}
inline ::message::StringMessage* MessageWrapper::unsafe_arena_release_string_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageWrapper.string_message)
  if (_internal_has_string_message()) {
    clear_has_payload();
    ::message::StringMessage* temp = payload_.string_message_;
    payload_.string_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageWrapper::unsafe_arena_set_allocated_string_message(::message::StringMessage* string_message) {
  clear_payload();
  if (string_message) {
    set_has_string_message();
    payload_.string_message_ = string_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageWrapper.string_message)
}
inline ::message::StringMessage* MessageWrapper::_internal_mutable_string_message() {
  if (!_internal_has_string_message()) {
    clear_payload();
    set_has_string_message();
    payload_.string_message_ = CreateMaybeMessage< ::message::StringMessage >(GetArenaForAllocation());
  }
  return payload_.string_message_;
}
inline ::message::StringMessage* MessageWrapper::mutable_string_message() {
  ::message::StringMessage* _msg = _internal_mutable_string_message();
  // @@protoc_insertion_point(field_mutable:message.MessageWrapper.string_message)
  return _msg;
}

// .message.LobbyMessage lobby_message = 3;
inline bool MessageWrapper::_internal_has_lobby_message() const {
  return payload_case() == kLobbyMessage;
}
inline bool MessageWrapper::has_lobby_message() const {
  return _internal_has_lobby_message();
}
inline void MessageWrapper::set_has_lobby_message() {
  _oneof_case_[0] = kLobbyMessage;
}
inline void MessageWrapper::clear_lobby_message() {
  if (_internal_has_lobby_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.lobby_message_;
    }
    clear_has_payload();
  }
}
inline ::message::LobbyMessage* MessageWrapper::release_lobby_message() {
  // @@protoc_insertion_point(field_release:message.MessageWrapper.lobby_message)
  if (_internal_has_lobby_message()) {
    clear_has_payload();
      ::message::LobbyMessage* temp = payload_.lobby_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.lobby_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::LobbyMessage& MessageWrapper::_internal_lobby_message() const {
  return _internal_has_lobby_message()
      ? *payload_.lobby_message_
      : reinterpret_cast< ::message::LobbyMessage&>(::message::_LobbyMessage_default_instance_);
}
inline const ::message::LobbyMessage& MessageWrapper::lobby_message() const {
  // @@protoc_insertion_point(field_get:message.MessageWrapper.lobby_message)
  return _internal_lobby_message();
}
inline ::message::LobbyMessage* MessageWrapper::unsafe_arena_release_lobby_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageWrapper.lobby_message)
  if (_internal_has_lobby_message()) {
    clear_has_payload();
    ::message::LobbyMessage* temp = payload_.lobby_message_;
    payload_.lobby_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageWrapper::unsafe_arena_set_allocated_lobby_message(::message::LobbyMessage* lobby_message) {
  clear_payload();
  if (lobby_message) {
    set_has_lobby_message();
    payload_.lobby_message_ = lobby_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageWrapper.lobby_message)
}
inline ::message::LobbyMessage* MessageWrapper::_internal_mutable_lobby_message() {
  if (!_internal_has_lobby_message()) {
    clear_payload();
    set_has_lobby_message();
    payload_.lobby_message_ = CreateMaybeMessage< ::message::LobbyMessage >(GetArenaForAllocation());
  }
  return payload_.lobby_message_;
}
inline ::message::LobbyMessage* MessageWrapper::mutable_lobby_message() {
  ::message::LobbyMessage* _msg = _internal_mutable_lobby_message();
  // @@protoc_insertion_point(field_mutable:message.MessageWrapper.lobby_message)
  return _msg;
}

// .message.StartReceiveMsgMessage start_receive_msg_message = 4;
inline bool MessageWrapper::_internal_has_start_receive_msg_message() const {
  return payload_case() == kStartReceiveMsgMessage;
}
inline bool MessageWrapper::has_start_receive_msg_message() const {
  return _internal_has_start_receive_msg_message();
}
inline void MessageWrapper::set_has_start_receive_msg_message() {
  _oneof_case_[0] = kStartReceiveMsgMessage;
}
inline void MessageWrapper::clear_start_receive_msg_message() {
  if (_internal_has_start_receive_msg_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.start_receive_msg_message_;
    }
    clear_has_payload();
  }
}
inline ::message::StartReceiveMsgMessage* MessageWrapper::release_start_receive_msg_message() {
  // @@protoc_insertion_point(field_release:message.MessageWrapper.start_receive_msg_message)
  if (_internal_has_start_receive_msg_message()) {
    clear_has_payload();
      ::message::StartReceiveMsgMessage* temp = payload_.start_receive_msg_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.start_receive_msg_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::StartReceiveMsgMessage& MessageWrapper::_internal_start_receive_msg_message() const {
  return _internal_has_start_receive_msg_message()
      ? *payload_.start_receive_msg_message_
      : reinterpret_cast< ::message::StartReceiveMsgMessage&>(::message::_StartReceiveMsgMessage_default_instance_);
}
inline const ::message::StartReceiveMsgMessage& MessageWrapper::start_receive_msg_message() const {
  // @@protoc_insertion_point(field_get:message.MessageWrapper.start_receive_msg_message)
  return _internal_start_receive_msg_message();
}
inline ::message::StartReceiveMsgMessage* MessageWrapper::unsafe_arena_release_start_receive_msg_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageWrapper.start_receive_msg_message)
  if (_internal_has_start_receive_msg_message()) {
    clear_has_payload();
    ::message::StartReceiveMsgMessage* temp = payload_.start_receive_msg_message_;
    payload_.start_receive_msg_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageWrapper::unsafe_arena_set_allocated_start_receive_msg_message(::message::StartReceiveMsgMessage* start_receive_msg_message) {
  clear_payload();
  if (start_receive_msg_message) {
    set_has_start_receive_msg_message();
    payload_.start_receive_msg_message_ = start_receive_msg_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageWrapper.start_receive_msg_message)
}
inline ::message::StartReceiveMsgMessage* MessageWrapper::_internal_mutable_start_receive_msg_message() {
  if (!_internal_has_start_receive_msg_message()) {
    clear_payload();
    set_has_start_receive_msg_message();
    payload_.start_receive_msg_message_ = CreateMaybeMessage< ::message::StartReceiveMsgMessage >(GetArenaForAllocation());
  }
  return payload_.start_receive_msg_message_;
}
inline ::message::StartReceiveMsgMessage* MessageWrapper::mutable_start_receive_msg_message() {
  ::message::StartReceiveMsgMessage* _msg = _internal_mutable_start_receive_msg_message();
  // @@protoc_insertion_point(field_mutable:message.MessageWrapper.start_receive_msg_message)
  return _msg;
}

// .message.PlayerBasicMessage player_basic_message = 5;
inline bool MessageWrapper::_internal_has_player_basic_message() const {
  return payload_case() == kPlayerBasicMessage;
}
inline bool MessageWrapper::has_player_basic_message() const {
  return _internal_has_player_basic_message();
}
inline void MessageWrapper::set_has_player_basic_message() {
  _oneof_case_[0] = kPlayerBasicMessage;
}
inline void MessageWrapper::clear_player_basic_message() {
  if (_internal_has_player_basic_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.player_basic_message_;
    }
    clear_has_payload();
  }
}
inline ::message::PlayerBasicMessage* MessageWrapper::release_player_basic_message() {
  // @@protoc_insertion_point(field_release:message.MessageWrapper.player_basic_message)
  if (_internal_has_player_basic_message()) {
    clear_has_payload();
      ::message::PlayerBasicMessage* temp = payload_.player_basic_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.player_basic_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::PlayerBasicMessage& MessageWrapper::_internal_player_basic_message() const {
  return _internal_has_player_basic_message()
      ? *payload_.player_basic_message_
      : reinterpret_cast< ::message::PlayerBasicMessage&>(::message::_PlayerBasicMessage_default_instance_);
}
inline const ::message::PlayerBasicMessage& MessageWrapper::player_basic_message() const {
  // @@protoc_insertion_point(field_get:message.MessageWrapper.player_basic_message)
  return _internal_player_basic_message();
}
inline ::message::PlayerBasicMessage* MessageWrapper::unsafe_arena_release_player_basic_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageWrapper.player_basic_message)
  if (_internal_has_player_basic_message()) {
    clear_has_payload();
    ::message::PlayerBasicMessage* temp = payload_.player_basic_message_;
    payload_.player_basic_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageWrapper::unsafe_arena_set_allocated_player_basic_message(::message::PlayerBasicMessage* player_basic_message) {
  clear_payload();
  if (player_basic_message) {
    set_has_player_basic_message();
    payload_.player_basic_message_ = player_basic_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageWrapper.player_basic_message)
}
inline ::message::PlayerBasicMessage* MessageWrapper::_internal_mutable_player_basic_message() {
  if (!_internal_has_player_basic_message()) {
    clear_payload();
    set_has_player_basic_message();
    payload_.player_basic_message_ = CreateMaybeMessage< ::message::PlayerBasicMessage >(GetArenaForAllocation());
  }
  return payload_.player_basic_message_;
}
inline ::message::PlayerBasicMessage* MessageWrapper::mutable_player_basic_message() {
  ::message::PlayerBasicMessage* _msg = _internal_mutable_player_basic_message();
  // @@protoc_insertion_point(field_mutable:message.MessageWrapper.player_basic_message)
  return _msg;
}

// .message.ReaperAttackMessage reaper_attack_message = 6;
inline bool MessageWrapper::_internal_has_reaper_attack_message() const {
  return payload_case() == kReaperAttackMessage;
}
inline bool MessageWrapper::has_reaper_attack_message() const {
  return _internal_has_reaper_attack_message();
}
inline void MessageWrapper::set_has_reaper_attack_message() {
  _oneof_case_[0] = kReaperAttackMessage;
}
inline void MessageWrapper::clear_reaper_attack_message() {
  if (_internal_has_reaper_attack_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.reaper_attack_message_;
    }
    clear_has_payload();
  }
}
inline ::message::ReaperAttackMessage* MessageWrapper::release_reaper_attack_message() {
  // @@protoc_insertion_point(field_release:message.MessageWrapper.reaper_attack_message)
  if (_internal_has_reaper_attack_message()) {
    clear_has_payload();
      ::message::ReaperAttackMessage* temp = payload_.reaper_attack_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.reaper_attack_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::ReaperAttackMessage& MessageWrapper::_internal_reaper_attack_message() const {
  return _internal_has_reaper_attack_message()
      ? *payload_.reaper_attack_message_
      : reinterpret_cast< ::message::ReaperAttackMessage&>(::message::_ReaperAttackMessage_default_instance_);
}
inline const ::message::ReaperAttackMessage& MessageWrapper::reaper_attack_message() const {
  // @@protoc_insertion_point(field_get:message.MessageWrapper.reaper_attack_message)
  return _internal_reaper_attack_message();
}
inline ::message::ReaperAttackMessage* MessageWrapper::unsafe_arena_release_reaper_attack_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageWrapper.reaper_attack_message)
  if (_internal_has_reaper_attack_message()) {
    clear_has_payload();
    ::message::ReaperAttackMessage* temp = payload_.reaper_attack_message_;
    payload_.reaper_attack_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageWrapper::unsafe_arena_set_allocated_reaper_attack_message(::message::ReaperAttackMessage* reaper_attack_message) {
  clear_payload();
  if (reaper_attack_message) {
    set_has_reaper_attack_message();
    payload_.reaper_attack_message_ = reaper_attack_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageWrapper.reaper_attack_message)
}
inline ::message::ReaperAttackMessage* MessageWrapper::_internal_mutable_reaper_attack_message() {
  if (!_internal_has_reaper_attack_message()) {
    clear_payload();
    set_has_reaper_attack_message();
    payload_.reaper_attack_message_ = CreateMaybeMessage< ::message::ReaperAttackMessage >(GetArenaForAllocation());
  }
  return payload_.reaper_attack_message_;
}
inline ::message::ReaperAttackMessage* MessageWrapper::mutable_reaper_attack_message() {
  ::message::ReaperAttackMessage* _msg = _internal_mutable_reaper_attack_message();
  // @@protoc_insertion_point(field_mutable:message.MessageWrapper.reaper_attack_message)
  return _msg;
}

// .message.ReaperAttackResultMessage reaper_attack_result_message = 7;
inline bool MessageWrapper::_internal_has_reaper_attack_result_message() const {
  return payload_case() == kReaperAttackResultMessage;
}
inline bool MessageWrapper::has_reaper_attack_result_message() const {
  return _internal_has_reaper_attack_result_message();
}
inline void MessageWrapper::set_has_reaper_attack_result_message() {
  _oneof_case_[0] = kReaperAttackResultMessage;
}
inline void MessageWrapper::clear_reaper_attack_result_message() {
  if (_internal_has_reaper_attack_result_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.reaper_attack_result_message_;
    }
    clear_has_payload();
  }
}
inline ::message::ReaperAttackResultMessage* MessageWrapper::release_reaper_attack_result_message() {
  // @@protoc_insertion_point(field_release:message.MessageWrapper.reaper_attack_result_message)
  if (_internal_has_reaper_attack_result_message()) {
    clear_has_payload();
      ::message::ReaperAttackResultMessage* temp = payload_.reaper_attack_result_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.reaper_attack_result_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::ReaperAttackResultMessage& MessageWrapper::_internal_reaper_attack_result_message() const {
  return _internal_has_reaper_attack_result_message()
      ? *payload_.reaper_attack_result_message_
      : reinterpret_cast< ::message::ReaperAttackResultMessage&>(::message::_ReaperAttackResultMessage_default_instance_);
}
inline const ::message::ReaperAttackResultMessage& MessageWrapper::reaper_attack_result_message() const {
  // @@protoc_insertion_point(field_get:message.MessageWrapper.reaper_attack_result_message)
  return _internal_reaper_attack_result_message();
}
inline ::message::ReaperAttackResultMessage* MessageWrapper::unsafe_arena_release_reaper_attack_result_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageWrapper.reaper_attack_result_message)
  if (_internal_has_reaper_attack_result_message()) {
    clear_has_payload();
    ::message::ReaperAttackResultMessage* temp = payload_.reaper_attack_result_message_;
    payload_.reaper_attack_result_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageWrapper::unsafe_arena_set_allocated_reaper_attack_result_message(::message::ReaperAttackResultMessage* reaper_attack_result_message) {
  clear_payload();
  if (reaper_attack_result_message) {
    set_has_reaper_attack_result_message();
    payload_.reaper_attack_result_message_ = reaper_attack_result_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageWrapper.reaper_attack_result_message)
}
inline ::message::ReaperAttackResultMessage* MessageWrapper::_internal_mutable_reaper_attack_result_message() {
  if (!_internal_has_reaper_attack_result_message()) {
    clear_payload();
    set_has_reaper_attack_result_message();
    payload_.reaper_attack_result_message_ = CreateMaybeMessage< ::message::ReaperAttackResultMessage >(GetArenaForAllocation());
  }
  return payload_.reaper_attack_result_message_;
}
inline ::message::ReaperAttackResultMessage* MessageWrapper::mutable_reaper_attack_result_message() {
  ::message::ReaperAttackResultMessage* _msg = _internal_mutable_reaper_attack_result_message();
  // @@protoc_insertion_point(field_mutable:message.MessageWrapper.reaper_attack_result_message)
  return _msg;
}

// .message.PropTryGetMessage prop_try_get_message = 8;
inline bool MessageWrapper::_internal_has_prop_try_get_message() const {
  return payload_case() == kPropTryGetMessage;
}
inline bool MessageWrapper::has_prop_try_get_message() const {
  return _internal_has_prop_try_get_message();
}
inline void MessageWrapper::set_has_prop_try_get_message() {
  _oneof_case_[0] = kPropTryGetMessage;
}
inline void MessageWrapper::clear_prop_try_get_message() {
  if (_internal_has_prop_try_get_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.prop_try_get_message_;
    }
    clear_has_payload();
  }
}
inline ::message::PropTryGetMessage* MessageWrapper::release_prop_try_get_message() {
  // @@protoc_insertion_point(field_release:message.MessageWrapper.prop_try_get_message)
  if (_internal_has_prop_try_get_message()) {
    clear_has_payload();
      ::message::PropTryGetMessage* temp = payload_.prop_try_get_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.prop_try_get_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::PropTryGetMessage& MessageWrapper::_internal_prop_try_get_message() const {
  return _internal_has_prop_try_get_message()
      ? *payload_.prop_try_get_message_
      : reinterpret_cast< ::message::PropTryGetMessage&>(::message::_PropTryGetMessage_default_instance_);
}
inline const ::message::PropTryGetMessage& MessageWrapper::prop_try_get_message() const {
  // @@protoc_insertion_point(field_get:message.MessageWrapper.prop_try_get_message)
  return _internal_prop_try_get_message();
}
inline ::message::PropTryGetMessage* MessageWrapper::unsafe_arena_release_prop_try_get_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageWrapper.prop_try_get_message)
  if (_internal_has_prop_try_get_message()) {
    clear_has_payload();
    ::message::PropTryGetMessage* temp = payload_.prop_try_get_message_;
    payload_.prop_try_get_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageWrapper::unsafe_arena_set_allocated_prop_try_get_message(::message::PropTryGetMessage* prop_try_get_message) {
  clear_payload();
  if (prop_try_get_message) {
    set_has_prop_try_get_message();
    payload_.prop_try_get_message_ = prop_try_get_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageWrapper.prop_try_get_message)
}
inline ::message::PropTryGetMessage* MessageWrapper::_internal_mutable_prop_try_get_message() {
  if (!_internal_has_prop_try_get_message()) {
    clear_payload();
    set_has_prop_try_get_message();
    payload_.prop_try_get_message_ = CreateMaybeMessage< ::message::PropTryGetMessage >(GetArenaForAllocation());
  }
  return payload_.prop_try_get_message_;
}
inline ::message::PropTryGetMessage* MessageWrapper::mutable_prop_try_get_message() {
  ::message::PropTryGetMessage* _msg = _internal_mutable_prop_try_get_message();
  // @@protoc_insertion_point(field_mutable:message.MessageWrapper.prop_try_get_message)
  return _msg;
}

// .message.PropGetMessage prop_get_message = 9;
inline bool MessageWrapper::_internal_has_prop_get_message() const {
  return payload_case() == kPropGetMessage;
}
inline bool MessageWrapper::has_prop_get_message() const {
  return _internal_has_prop_get_message();
}
inline void MessageWrapper::set_has_prop_get_message() {
  _oneof_case_[0] = kPropGetMessage;
}
inline void MessageWrapper::clear_prop_get_message() {
  if (_internal_has_prop_get_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.prop_get_message_;
    }
    clear_has_payload();
  }
}
inline ::message::PropGetMessage* MessageWrapper::release_prop_get_message() {
  // @@protoc_insertion_point(field_release:message.MessageWrapper.prop_get_message)
  if (_internal_has_prop_get_message()) {
    clear_has_payload();
      ::message::PropGetMessage* temp = payload_.prop_get_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.prop_get_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::PropGetMessage& MessageWrapper::_internal_prop_get_message() const {
  return _internal_has_prop_get_message()
      ? *payload_.prop_get_message_
      : reinterpret_cast< ::message::PropGetMessage&>(::message::_PropGetMessage_default_instance_);
}
inline const ::message::PropGetMessage& MessageWrapper::prop_get_message() const {
  // @@protoc_insertion_point(field_get:message.MessageWrapper.prop_get_message)
  return _internal_prop_get_message();
}
inline ::message::PropGetMessage* MessageWrapper::unsafe_arena_release_prop_get_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageWrapper.prop_get_message)
  if (_internal_has_prop_get_message()) {
    clear_has_payload();
    ::message::PropGetMessage* temp = payload_.prop_get_message_;
    payload_.prop_get_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageWrapper::unsafe_arena_set_allocated_prop_get_message(::message::PropGetMessage* prop_get_message) {
  clear_payload();
  if (prop_get_message) {
    set_has_prop_get_message();
    payload_.prop_get_message_ = prop_get_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageWrapper.prop_get_message)
}
inline ::message::PropGetMessage* MessageWrapper::_internal_mutable_prop_get_message() {
  if (!_internal_has_prop_get_message()) {
    clear_payload();
    set_has_prop_get_message();
    payload_.prop_get_message_ = CreateMaybeMessage< ::message::PropGetMessage >(GetArenaForAllocation());
  }
  return payload_.prop_get_message_;
}
inline ::message::PropGetMessage* MessageWrapper::mutable_prop_get_message() {
  ::message::PropGetMessage* _msg = _internal_mutable_prop_get_message();
  // @@protoc_insertion_point(field_mutable:message.MessageWrapper.prop_get_message)
  return _msg;
}

// .message.IntegerMessage integer_message = 10;
inline bool MessageWrapper::_internal_has_integer_message() const {
  return payload_case() == kIntegerMessage;
}
inline bool MessageWrapper::has_integer_message() const {
  return _internal_has_integer_message();
}
inline void MessageWrapper::set_has_integer_message() {
  _oneof_case_[0] = kIntegerMessage;
}
inline void MessageWrapper::clear_integer_message() {
  if (_internal_has_integer_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.integer_message_;
    }
    clear_has_payload();
  }
}
inline ::message::IntegerMessage* MessageWrapper::release_integer_message() {
  // @@protoc_insertion_point(field_release:message.MessageWrapper.integer_message)
  if (_internal_has_integer_message()) {
    clear_has_payload();
      ::message::IntegerMessage* temp = payload_.integer_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.integer_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::IntegerMessage& MessageWrapper::_internal_integer_message() const {
  return _internal_has_integer_message()
      ? *payload_.integer_message_
      : reinterpret_cast< ::message::IntegerMessage&>(::message::_IntegerMessage_default_instance_);
}
inline const ::message::IntegerMessage& MessageWrapper::integer_message() const {
  // @@protoc_insertion_point(field_get:message.MessageWrapper.integer_message)
  return _internal_integer_message();
}
inline ::message::IntegerMessage* MessageWrapper::unsafe_arena_release_integer_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageWrapper.integer_message)
  if (_internal_has_integer_message()) {
    clear_has_payload();
    ::message::IntegerMessage* temp = payload_.integer_message_;
    payload_.integer_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageWrapper::unsafe_arena_set_allocated_integer_message(::message::IntegerMessage* integer_message) {
  clear_payload();
  if (integer_message) {
    set_has_integer_message();
    payload_.integer_message_ = integer_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageWrapper.integer_message)
}
inline ::message::IntegerMessage* MessageWrapper::_internal_mutable_integer_message() {
  if (!_internal_has_integer_message()) {
    clear_payload();
    set_has_integer_message();
    payload_.integer_message_ = CreateMaybeMessage< ::message::IntegerMessage >(GetArenaForAllocation());
  }
  return payload_.integer_message_;
}
inline ::message::IntegerMessage* MessageWrapper::mutable_integer_message() {
  ::message::IntegerMessage* _msg = _internal_mutable_integer_message();
  // @@protoc_insertion_point(field_mutable:message.MessageWrapper.integer_message)
  return _msg;
}

inline bool MessageWrapper::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void MessageWrapper::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline MessageWrapper::PayloadCase MessageWrapper::payload_case() const {
  return MessageWrapper::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RoomMessage

// bool is_join = 1;
inline void RoomMessage::clear_is_join() {
  is_join_ = false;
}
inline bool RoomMessage::_internal_is_join() const {
  return is_join_;
}
inline bool RoomMessage::is_join() const {
  // @@protoc_insertion_point(field_get:message.RoomMessage.is_join)
  return _internal_is_join();
}
inline void RoomMessage::_internal_set_is_join(bool value) {
  
  is_join_ = value;
}
inline void RoomMessage::set_is_join(bool value) {
  _internal_set_is_join(value);
  // @@protoc_insertion_point(field_set:message.RoomMessage.is_join)
}

// int32 room_id = 2;
inline void RoomMessage::clear_room_id() {
  room_id_ = 0;
}
inline int32_t RoomMessage::_internal_room_id() const {
  return room_id_;
}
inline int32_t RoomMessage::room_id() const {
  // @@protoc_insertion_point(field_get:message.RoomMessage.room_id)
  return _internal_room_id();
}
inline void RoomMessage::_internal_set_room_id(int32_t value) {
  
  room_id_ = value;
}
inline void RoomMessage::set_room_id(int32_t value) {
  _internal_set_room_id(value);
  // @@protoc_insertion_point(field_set:message.RoomMessage.room_id)
}

// int32 player_id = 3;
inline void RoomMessage::clear_player_id() {
  player_id_ = 0;
}
inline int32_t RoomMessage::_internal_player_id() const {
  return player_id_;
}
inline int32_t RoomMessage::player_id() const {
  // @@protoc_insertion_point(field_get:message.RoomMessage.player_id)
  return _internal_player_id();
}
inline void RoomMessage::_internal_set_player_id(int32_t value) {
  
  player_id_ = value;
}
inline void RoomMessage::set_player_id(int32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:message.RoomMessage.player_id)
}

// repeated .message.Character characters = 4;
inline int RoomMessage::_internal_characters_size() const {
  return characters_.size();
}
inline int RoomMessage::characters_size() const {
  return _internal_characters_size();
}
inline void RoomMessage::clear_characters() {
  characters_.Clear();
}
inline ::message::Character* RoomMessage::mutable_characters(int index) {
  // @@protoc_insertion_point(field_mutable:message.RoomMessage.characters)
  return characters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::Character >*
RoomMessage::mutable_characters() {
  // @@protoc_insertion_point(field_mutable_list:message.RoomMessage.characters)
  return &characters_;
}
inline const ::message::Character& RoomMessage::_internal_characters(int index) const {
  return characters_.Get(index);
}
inline const ::message::Character& RoomMessage::characters(int index) const {
  // @@protoc_insertion_point(field_get:message.RoomMessage.characters)
  return _internal_characters(index);
}
inline ::message::Character* RoomMessage::_internal_add_characters() {
  return characters_.Add();
}
inline ::message::Character* RoomMessage::add_characters() {
  ::message::Character* _add = _internal_add_characters();
  // @@protoc_insertion_point(field_add:message.RoomMessage.characters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::Character >&
RoomMessage::characters() const {
  // @@protoc_insertion_point(field_list:message.RoomMessage.characters)
  return characters_;
}

// -------------------------------------------------------------------

// StringMessage

// int32 message_type = 1;
inline void StringMessage::clear_message_type() {
  message_type_ = 0;
}
inline int32_t StringMessage::_internal_message_type() const {
  return message_type_;
}
inline int32_t StringMessage::message_type() const {
  // @@protoc_insertion_point(field_get:message.StringMessage.message_type)
  return _internal_message_type();
}
inline void StringMessage::_internal_set_message_type(int32_t value) {
  
  message_type_ = value;
}
inline void StringMessage::set_message_type(int32_t value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:message.StringMessage.message_type)
}

// string message_content = 2;
inline void StringMessage::clear_message_content() {
  message_content_.ClearToEmpty();
}
inline const std::string& StringMessage::message_content() const {
  // @@protoc_insertion_point(field_get:message.StringMessage.message_content)
  return _internal_message_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StringMessage::set_message_content(ArgT0&& arg0, ArgT... args) {
 
 message_content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:message.StringMessage.message_content)
}
inline std::string* StringMessage::mutable_message_content() {
  std::string* _s = _internal_mutable_message_content();
  // @@protoc_insertion_point(field_mutable:message.StringMessage.message_content)
  return _s;
}
inline const std::string& StringMessage::_internal_message_content() const {
  return message_content_.Get();
}
inline void StringMessage::_internal_set_message_content(const std::string& value) {
  
  message_content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StringMessage::_internal_mutable_message_content() {
  
  return message_content_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StringMessage::release_message_content() {
  // @@protoc_insertion_point(field_release:message.StringMessage.message_content)
  return message_content_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StringMessage::set_allocated_message_content(std::string* message_content) {
  if (message_content != nullptr) {
    
  } else {
    
  }
  message_content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message_content,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_content_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.StringMessage.message_content)
}

// -------------------------------------------------------------------

// LobbyMessage

// bool is_ready = 1;
inline void LobbyMessage::clear_is_ready() {
  is_ready_ = false;
}
inline bool LobbyMessage::_internal_is_ready() const {
  return is_ready_;
}
inline bool LobbyMessage::is_ready() const {
  // @@protoc_insertion_point(field_get:message.LobbyMessage.is_ready)
  return _internal_is_ready();
}
inline void LobbyMessage::_internal_set_is_ready(bool value) {
  
  is_ready_ = value;
}
inline void LobbyMessage::set_is_ready(bool value) {
  _internal_set_is_ready(value);
  // @@protoc_insertion_point(field_set:message.LobbyMessage.is_ready)
}

// int32 player_id = 2;
inline void LobbyMessage::clear_player_id() {
  player_id_ = 0;
}
inline int32_t LobbyMessage::_internal_player_id() const {
  return player_id_;
}
inline int32_t LobbyMessage::player_id() const {
  // @@protoc_insertion_point(field_get:message.LobbyMessage.player_id)
  return _internal_player_id();
}
inline void LobbyMessage::_internal_set_player_id(int32_t value) {
  
  player_id_ = value;
}
inline void LobbyMessage::set_player_id(int32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:message.LobbyMessage.player_id)
}

// .message.CharacterType character_type = 3;
inline void LobbyMessage::clear_character_type() {
  character_type_ = 0;
}
inline ::message::CharacterType LobbyMessage::_internal_character_type() const {
  return static_cast< ::message::CharacterType >(character_type_);
}
inline ::message::CharacterType LobbyMessage::character_type() const {
  // @@protoc_insertion_point(field_get:message.LobbyMessage.character_type)
  return _internal_character_type();
}
inline void LobbyMessage::_internal_set_character_type(::message::CharacterType value) {
  
  character_type_ = value;
}
inline void LobbyMessage::set_character_type(::message::CharacterType value) {
  _internal_set_character_type(value);
  // @@protoc_insertion_point(field_set:message.LobbyMessage.character_type)
}

// -------------------------------------------------------------------

// StartReceiveMsgMessage

// int32 player_id = 1;
inline void StartReceiveMsgMessage::clear_player_id() {
  player_id_ = 0;
}
inline int32_t StartReceiveMsgMessage::_internal_player_id() const {
  return player_id_;
}
inline int32_t StartReceiveMsgMessage::player_id() const {
  // @@protoc_insertion_point(field_get:message.StartReceiveMsgMessage.player_id)
  return _internal_player_id();
}
inline void StartReceiveMsgMessage::_internal_set_player_id(int32_t value) {
  
  player_id_ = value;
}
inline void StartReceiveMsgMessage::set_player_id(int32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:message.StartReceiveMsgMessage.player_id)
}

// -------------------------------------------------------------------

// PlayerBasicMessage

// int32 player_id = 1;
inline void PlayerBasicMessage::clear_player_id() {
  player_id_ = 0;
}
inline int32_t PlayerBasicMessage::_internal_player_id() const {
  return player_id_;
}
inline int32_t PlayerBasicMessage::player_id() const {
  // @@protoc_insertion_point(field_get:message.PlayerBasicMessage.player_id)
  return _internal_player_id();
}
inline void PlayerBasicMessage::_internal_set_player_id(int32_t value) {
  
  player_id_ = value;
}
inline void PlayerBasicMessage::set_player_id(int32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:message.PlayerBasicMessage.player_id)
}

// float position_x = 2;
inline void PlayerBasicMessage::clear_position_x() {
  position_x_ = 0;
}
inline float PlayerBasicMessage::_internal_position_x() const {
  return position_x_;
}
inline float PlayerBasicMessage::position_x() const {
  // @@protoc_insertion_point(field_get:message.PlayerBasicMessage.position_x)
  return _internal_position_x();
}
inline void PlayerBasicMessage::_internal_set_position_x(float value) {
  
  position_x_ = value;
}
inline void PlayerBasicMessage::set_position_x(float value) {
  _internal_set_position_x(value);
  // @@protoc_insertion_point(field_set:message.PlayerBasicMessage.position_x)
}

// float position_y = 3;
inline void PlayerBasicMessage::clear_position_y() {
  position_y_ = 0;
}
inline float PlayerBasicMessage::_internal_position_y() const {
  return position_y_;
}
inline float PlayerBasicMessage::position_y() const {
  // @@protoc_insertion_point(field_get:message.PlayerBasicMessage.position_y)
  return _internal_position_y();
}
inline void PlayerBasicMessage::_internal_set_position_y(float value) {
  
  position_y_ = value;
}
inline void PlayerBasicMessage::set_position_y(float value) {
  _internal_set_position_y(value);
  // @@protoc_insertion_point(field_set:message.PlayerBasicMessage.position_y)
}

// float hp = 4;
inline void PlayerBasicMessage::clear_hp() {
  hp_ = 0;
}
inline float PlayerBasicMessage::_internal_hp() const {
  return hp_;
}
inline float PlayerBasicMessage::hp() const {
  // @@protoc_insertion_point(field_get:message.PlayerBasicMessage.hp)
  return _internal_hp();
}
inline void PlayerBasicMessage::_internal_set_hp(float value) {
  
  hp_ = value;
}
inline void PlayerBasicMessage::set_hp(float value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:message.PlayerBasicMessage.hp)
}

// float max_hp = 5;
inline void PlayerBasicMessage::clear_max_hp() {
  max_hp_ = 0;
}
inline float PlayerBasicMessage::_internal_max_hp() const {
  return max_hp_;
}
inline float PlayerBasicMessage::max_hp() const {
  // @@protoc_insertion_point(field_get:message.PlayerBasicMessage.max_hp)
  return _internal_max_hp();
}
inline void PlayerBasicMessage::_internal_set_max_hp(float value) {
  
  max_hp_ = value;
}
inline void PlayerBasicMessage::set_max_hp(float value) {
  _internal_set_max_hp(value);
  // @@protoc_insertion_point(field_set:message.PlayerBasicMessage.max_hp)
}

// .message.PlayerAnimationType animation_type = 6;
inline void PlayerBasicMessage::clear_animation_type() {
  animation_type_ = 0;
}
inline ::message::PlayerAnimationType PlayerBasicMessage::_internal_animation_type() const {
  return static_cast< ::message::PlayerAnimationType >(animation_type_);
}
inline ::message::PlayerAnimationType PlayerBasicMessage::animation_type() const {
  // @@protoc_insertion_point(field_get:message.PlayerBasicMessage.animation_type)
  return _internal_animation_type();
}
inline void PlayerBasicMessage::_internal_set_animation_type(::message::PlayerAnimationType value) {
  
  animation_type_ = value;
}
inline void PlayerBasicMessage::set_animation_type(::message::PlayerAnimationType value) {
  _internal_set_animation_type(value);
  // @@protoc_insertion_point(field_set:message.PlayerBasicMessage.animation_type)
}

// -------------------------------------------------------------------

// SoulStateMessage

// int32 soul_player_id = 1;
inline void SoulStateMessage::clear_soul_player_id() {
  soul_player_id_ = 0;
}
inline int32_t SoulStateMessage::_internal_soul_player_id() const {
  return soul_player_id_;
}
inline int32_t SoulStateMessage::soul_player_id() const {
  // @@protoc_insertion_point(field_get:message.SoulStateMessage.soul_player_id)
  return _internal_soul_player_id();
}
inline void SoulStateMessage::_internal_set_soul_player_id(int32_t value) {
  
  soul_player_id_ = value;
}
inline void SoulStateMessage::set_soul_player_id(int32_t value) {
  _internal_set_soul_player_id(value);
  // @@protoc_insertion_point(field_set:message.SoulStateMessage.soul_player_id)
}

// .message.SoulState soul_state = 2;
inline void SoulStateMessage::clear_soul_state() {
  soul_state_ = 0;
}
inline ::message::SoulState SoulStateMessage::_internal_soul_state() const {
  return static_cast< ::message::SoulState >(soul_state_);
}
inline ::message::SoulState SoulStateMessage::soul_state() const {
  // @@protoc_insertion_point(field_get:message.SoulStateMessage.soul_state)
  return _internal_soul_state();
}
inline void SoulStateMessage::_internal_set_soul_state(::message::SoulState value) {
  
  soul_state_ = value;
}
inline void SoulStateMessage::set_soul_state(::message::SoulState value) {
  _internal_set_soul_state(value);
  // @@protoc_insertion_point(field_set:message.SoulStateMessage.soul_state)
}

// -------------------------------------------------------------------

// ReaperAttackMessage

// int32 soul_player_id = 1;
inline void ReaperAttackMessage::clear_soul_player_id() {
  soul_player_id_ = 0;
}
inline int32_t ReaperAttackMessage::_internal_soul_player_id() const {
  return soul_player_id_;
}
inline int32_t ReaperAttackMessage::soul_player_id() const {
  // @@protoc_insertion_point(field_get:message.ReaperAttackMessage.soul_player_id)
  return _internal_soul_player_id();
}
inline void ReaperAttackMessage::_internal_set_soul_player_id(int32_t value) {
  
  soul_player_id_ = value;
}
inline void ReaperAttackMessage::set_soul_player_id(int32_t value) {
  _internal_set_soul_player_id(value);
  // @@protoc_insertion_point(field_set:message.ReaperAttackMessage.soul_player_id)
}

// int32 skill_id = 2;
inline void ReaperAttackMessage::clear_skill_id() {
  skill_id_ = 0;
}
inline int32_t ReaperAttackMessage::_internal_skill_id() const {
  return skill_id_;
}
inline int32_t ReaperAttackMessage::skill_id() const {
  // @@protoc_insertion_point(field_get:message.ReaperAttackMessage.skill_id)
  return _internal_skill_id();
}
inline void ReaperAttackMessage::_internal_set_skill_id(int32_t value) {
  
  skill_id_ = value;
}
inline void ReaperAttackMessage::set_skill_id(int32_t value) {
  _internal_set_skill_id(value);
  // @@protoc_insertion_point(field_set:message.ReaperAttackMessage.skill_id)
}

// -------------------------------------------------------------------

// PropTryGetMessage

// int32 player_id = 1;
inline void PropTryGetMessage::clear_player_id() {
  player_id_ = 0;
}
inline int32_t PropTryGetMessage::_internal_player_id() const {
  return player_id_;
}
inline int32_t PropTryGetMessage::player_id() const {
  // @@protoc_insertion_point(field_get:message.PropTryGetMessage.player_id)
  return _internal_player_id();
}
inline void PropTryGetMessage::_internal_set_player_id(int32_t value) {
  
  player_id_ = value;
}
inline void PropTryGetMessage::set_player_id(int32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:message.PropTryGetMessage.player_id)
}

// int32 prop_id = 2;
inline void PropTryGetMessage::clear_prop_id() {
  prop_id_ = 0;
}
inline int32_t PropTryGetMessage::_internal_prop_id() const {
  return prop_id_;
}
inline int32_t PropTryGetMessage::prop_id() const {
  // @@protoc_insertion_point(field_get:message.PropTryGetMessage.prop_id)
  return _internal_prop_id();
}
inline void PropTryGetMessage::_internal_set_prop_id(int32_t value) {
  
  prop_id_ = value;
}
inline void PropTryGetMessage::set_prop_id(int32_t value) {
  _internal_set_prop_id(value);
  // @@protoc_insertion_point(field_set:message.PropTryGetMessage.prop_id)
}

// int32 prop_type = 3;
inline void PropTryGetMessage::clear_prop_type() {
  prop_type_ = 0;
}
inline int32_t PropTryGetMessage::_internal_prop_type() const {
  return prop_type_;
}
inline int32_t PropTryGetMessage::prop_type() const {
  // @@protoc_insertion_point(field_get:message.PropTryGetMessage.prop_type)
  return _internal_prop_type();
}
inline void PropTryGetMessage::_internal_set_prop_type(int32_t value) {
  
  prop_type_ = value;
}
inline void PropTryGetMessage::set_prop_type(int32_t value) {
  _internal_set_prop_type(value);
  // @@protoc_insertion_point(field_set:message.PropTryGetMessage.prop_type)
}

// -------------------------------------------------------------------

// PropGetMessage

// bool is_get = 1;
inline void PropGetMessage::clear_is_get() {
  is_get_ = false;
}
inline bool PropGetMessage::_internal_is_get() const {
  return is_get_;
}
inline bool PropGetMessage::is_get() const {
  // @@protoc_insertion_point(field_get:message.PropGetMessage.is_get)
  return _internal_is_get();
}
inline void PropGetMessage::_internal_set_is_get(bool value) {
  
  is_get_ = value;
}
inline void PropGetMessage::set_is_get(bool value) {
  _internal_set_is_get(value);
  // @@protoc_insertion_point(field_set:message.PropGetMessage.is_get)
}

// int32 player_id = 2;
inline void PropGetMessage::clear_player_id() {
  player_id_ = 0;
}
inline int32_t PropGetMessage::_internal_player_id() const {
  return player_id_;
}
inline int32_t PropGetMessage::player_id() const {
  // @@protoc_insertion_point(field_get:message.PropGetMessage.player_id)
  return _internal_player_id();
}
inline void PropGetMessage::_internal_set_player_id(int32_t value) {
  
  player_id_ = value;
}
inline void PropGetMessage::set_player_id(int32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:message.PropGetMessage.player_id)
}

// int32 prop_id = 3;
inline void PropGetMessage::clear_prop_id() {
  prop_id_ = 0;
}
inline int32_t PropGetMessage::_internal_prop_id() const {
  return prop_id_;
}
inline int32_t PropGetMessage::prop_id() const {
  // @@protoc_insertion_point(field_get:message.PropGetMessage.prop_id)
  return _internal_prop_id();
}
inline void PropGetMessage::_internal_set_prop_id(int32_t value) {
  
  prop_id_ = value;
}
inline void PropGetMessage::set_prop_id(int32_t value) {
  _internal_set_prop_id(value);
  // @@protoc_insertion_point(field_set:message.PropGetMessage.prop_id)
}

// -------------------------------------------------------------------

// ReaperAttackResultMessage

// int32 soul_player_id = 1;
inline void ReaperAttackResultMessage::clear_soul_player_id() {
  soul_player_id_ = 0;
}
inline int32_t ReaperAttackResultMessage::_internal_soul_player_id() const {
  return soul_player_id_;
}
inline int32_t ReaperAttackResultMessage::soul_player_id() const {
  // @@protoc_insertion_point(field_get:message.ReaperAttackResultMessage.soul_player_id)
  return _internal_soul_player_id();
}
inline void ReaperAttackResultMessage::_internal_set_soul_player_id(int32_t value) {
  
  soul_player_id_ = value;
}
inline void ReaperAttackResultMessage::set_soul_player_id(int32_t value) {
  _internal_set_soul_player_id(value);
  // @@protoc_insertion_point(field_set:message.ReaperAttackResultMessage.soul_player_id)
}

// bool is_hit = 2;
inline void ReaperAttackResultMessage::clear_is_hit() {
  is_hit_ = false;
}
inline bool ReaperAttackResultMessage::_internal_is_hit() const {
  return is_hit_;
}
inline bool ReaperAttackResultMessage::is_hit() const {
  // @@protoc_insertion_point(field_get:message.ReaperAttackResultMessage.is_hit)
  return _internal_is_hit();
}
inline void ReaperAttackResultMessage::_internal_set_is_hit(bool value) {
  
  is_hit_ = value;
}
inline void ReaperAttackResultMessage::set_is_hit(bool value) {
  _internal_set_is_hit(value);
  // @@protoc_insertion_point(field_set:message.ReaperAttackResultMessage.is_hit)
}

// -------------------------------------------------------------------

// IntegerMessage

// .message.IntegerMessageType message_type = 1;
inline void IntegerMessage::clear_message_type() {
  message_type_ = 0;
}
inline ::message::IntegerMessageType IntegerMessage::_internal_message_type() const {
  return static_cast< ::message::IntegerMessageType >(message_type_);
}
inline ::message::IntegerMessageType IntegerMessage::message_type() const {
  // @@protoc_insertion_point(field_get:message.IntegerMessage.message_type)
  return _internal_message_type();
}
inline void IntegerMessage::_internal_set_message_type(::message::IntegerMessageType value) {
  
  message_type_ = value;
}
inline void IntegerMessage::set_message_type(::message::IntegerMessageType value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:message.IntegerMessage.message_type)
}

// int32 value = 2;
inline void IntegerMessage::clear_value() {
  value_ = 0;
}
inline int32_t IntegerMessage::_internal_value() const {
  return value_;
}
inline int32_t IntegerMessage::value() const {
  // @@protoc_insertion_point(field_get:message.IntegerMessage.value)
  return _internal_value();
}
inline void IntegerMessage::_internal_set_value(int32_t value) {
  
  value_ = value;
}
inline void IntegerMessage::set_value(int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:message.IntegerMessage.value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace message

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::message::CharacterType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message::CharacterType>() {
  return ::message::CharacterType_descriptor();
}
template <> struct is_proto_enum< ::message::StringMessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message::StringMessageType>() {
  return ::message::StringMessageType_descriptor();
}
template <> struct is_proto_enum< ::message::PlayerAnimationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message::PlayerAnimationType>() {
  return ::message::PlayerAnimationType_descriptor();
}
template <> struct is_proto_enum< ::message::SoulState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message::SoulState>() {
  return ::message::SoulState_descriptor();
}
template <> struct is_proto_enum< ::message::IntegerMessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message::IntegerMessageType>() {
  return ::message::IntegerMessageType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_message_2eproto
