// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_message_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_message_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_message_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_message_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_message_2eproto;
namespace message {
class Character;
struct CharacterDefaultTypeInternal;
extern CharacterDefaultTypeInternal _Character_default_instance_;
class EnterGateMessage;
struct EnterGateMessageDefaultTypeInternal;
extern EnterGateMessageDefaultTypeInternal _EnterGateMessage_default_instance_;
class EnterGateResultMessage;
struct EnterGateResultMessageDefaultTypeInternal;
extern EnterGateResultMessageDefaultTypeInternal _EnterGateResultMessage_default_instance_;
class Gate;
struct GateDefaultTypeInternal;
extern GateDefaultTypeInternal _Gate_default_instance_;
class GateMessage;
struct GateMessageDefaultTypeInternal;
extern GateMessageDefaultTypeInternal _GateMessage_default_instance_;
class HelloMessage;
struct HelloMessageDefaultTypeInternal;
extern HelloMessageDefaultTypeInternal _HelloMessage_default_instance_;
class IntegerMessage;
struct IntegerMessageDefaultTypeInternal;
extern IntegerMessageDefaultTypeInternal _IntegerMessage_default_instance_;
class LobbyMessage;
struct LobbyMessageDefaultTypeInternal;
extern LobbyMessageDefaultTypeInternal _LobbyMessage_default_instance_;
class MessageWrapper;
struct MessageWrapperDefaultTypeInternal;
extern MessageWrapperDefaultTypeInternal _MessageWrapper_default_instance_;
class PlayerBasicMessage;
struct PlayerBasicMessageDefaultTypeInternal;
extern PlayerBasicMessageDefaultTypeInternal _PlayerBasicMessage_default_instance_;
class PropGetMessage;
struct PropGetMessageDefaultTypeInternal;
extern PropGetMessageDefaultTypeInternal _PropGetMessage_default_instance_;
class PropTryGetMessage;
struct PropTryGetMessageDefaultTypeInternal;
extern PropTryGetMessageDefaultTypeInternal _PropTryGetMessage_default_instance_;
class RoomMessage;
struct RoomMessageDefaultTypeInternal;
extern RoomMessageDefaultTypeInternal _RoomMessage_default_instance_;
class StartReceiveMsgMessage;
struct StartReceiveMsgMessageDefaultTypeInternal;
extern StartReceiveMsgMessageDefaultTypeInternal _StartReceiveMsgMessage_default_instance_;
class StringMessage;
struct StringMessageDefaultTypeInternal;
extern StringMessageDefaultTypeInternal _StringMessage_default_instance_;
}  // namespace message
PROTOBUF_NAMESPACE_OPEN
template<> ::message::Character* Arena::CreateMaybeMessage<::message::Character>(Arena*);
template<> ::message::EnterGateMessage* Arena::CreateMaybeMessage<::message::EnterGateMessage>(Arena*);
template<> ::message::EnterGateResultMessage* Arena::CreateMaybeMessage<::message::EnterGateResultMessage>(Arena*);
template<> ::message::Gate* Arena::CreateMaybeMessage<::message::Gate>(Arena*);
template<> ::message::GateMessage* Arena::CreateMaybeMessage<::message::GateMessage>(Arena*);
template<> ::message::HelloMessage* Arena::CreateMaybeMessage<::message::HelloMessage>(Arena*);
template<> ::message::IntegerMessage* Arena::CreateMaybeMessage<::message::IntegerMessage>(Arena*);
template<> ::message::LobbyMessage* Arena::CreateMaybeMessage<::message::LobbyMessage>(Arena*);
template<> ::message::MessageWrapper* Arena::CreateMaybeMessage<::message::MessageWrapper>(Arena*);
template<> ::message::PlayerBasicMessage* Arena::CreateMaybeMessage<::message::PlayerBasicMessage>(Arena*);
template<> ::message::PropGetMessage* Arena::CreateMaybeMessage<::message::PropGetMessage>(Arena*);
template<> ::message::PropTryGetMessage* Arena::CreateMaybeMessage<::message::PropTryGetMessage>(Arena*);
template<> ::message::RoomMessage* Arena::CreateMaybeMessage<::message::RoomMessage>(Arena*);
template<> ::message::StartReceiveMsgMessage* Arena::CreateMaybeMessage<::message::StartReceiveMsgMessage>(Arena*);
template<> ::message::StringMessage* Arena::CreateMaybeMessage<::message::StringMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace message {

enum CharacterType : int {
  REAPER = 0,
  SOUL_DOG = 1,
  SOUL_PSYCHOLOGIST = 2,
  SOUL_DETECTIVE = 3,
  CharacterType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CharacterType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CharacterType_IsValid(int value);
constexpr CharacterType CharacterType_MIN = REAPER;
constexpr CharacterType CharacterType_MAX = SOUL_DETECTIVE;
constexpr int CharacterType_ARRAYSIZE = CharacterType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CharacterType_descriptor();
template<typename T>
inline const std::string& CharacterType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CharacterType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CharacterType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CharacterType_descriptor(), enum_t_value);
}
inline bool CharacterType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CharacterType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CharacterType>(
    CharacterType_descriptor(), name, value);
}
enum StringMessageType : int {
  MAZE_MAP = 0,
  StringMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StringMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StringMessageType_IsValid(int value);
constexpr StringMessageType StringMessageType_MIN = MAZE_MAP;
constexpr StringMessageType StringMessageType_MAX = MAZE_MAP;
constexpr int StringMessageType_ARRAYSIZE = StringMessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StringMessageType_descriptor();
template<typename T>
inline const std::string& StringMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StringMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StringMessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StringMessageType_descriptor(), enum_t_value);
}
inline bool StringMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StringMessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StringMessageType>(
    StringMessageType_descriptor(), name, value);
}
enum PlayerAnimationType : int {
  IDLE = 0,
  WALK_LEFT = 1,
  WALK_RIGHT = 2,
  DASH_LEFT = 3,
  DASH_RIGHT = 4,
  ATTACK = 5,
  HIT = 6,
  WEAK = 7,
  DIE = 8,
  PlayerAnimationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PlayerAnimationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PlayerAnimationType_IsValid(int value);
constexpr PlayerAnimationType PlayerAnimationType_MIN = IDLE;
constexpr PlayerAnimationType PlayerAnimationType_MAX = DIE;
constexpr int PlayerAnimationType_ARRAYSIZE = PlayerAnimationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayerAnimationType_descriptor();
template<typename T>
inline const std::string& PlayerAnimationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayerAnimationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayerAnimationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlayerAnimationType_descriptor(), enum_t_value);
}
inline bool PlayerAnimationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlayerAnimationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayerAnimationType>(
    PlayerAnimationType_descriptor(), name, value);
}
enum CharacterState : int {
  Character_STATE_NORMAL = 0,
  Character_STATE_WEAK = 1,
  Character_STATE_DIE = 2,
  Character_STATE_FREEZE = 3,
  CharacterState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CharacterState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CharacterState_IsValid(int value);
constexpr CharacterState CharacterState_MIN = Character_STATE_NORMAL;
constexpr CharacterState CharacterState_MAX = Character_STATE_FREEZE;
constexpr int CharacterState_ARRAYSIZE = CharacterState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CharacterState_descriptor();
template<typename T>
inline const std::string& CharacterState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CharacterState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CharacterState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CharacterState_descriptor(), enum_t_value);
}
inline bool CharacterState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CharacterState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CharacterState>(
    CharacterState_descriptor(), name, value);
}
enum IntegerMessageType : int {
  ALTAR_MINI_GAME_SUCCESS = 0,
  REAPER_ATTACK_RESULT = 1,
  IntegerMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IntegerMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IntegerMessageType_IsValid(int value);
constexpr IntegerMessageType IntegerMessageType_MIN = ALTAR_MINI_GAME_SUCCESS;
constexpr IntegerMessageType IntegerMessageType_MAX = REAPER_ATTACK_RESULT;
constexpr int IntegerMessageType_ARRAYSIZE = IntegerMessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IntegerMessageType_descriptor();
template<typename T>
inline const std::string& IntegerMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IntegerMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IntegerMessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IntegerMessageType_descriptor(), enum_t_value);
}
inline bool IntegerMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IntegerMessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IntegerMessageType>(
    IntegerMessageType_descriptor(), name, value);
}
enum GateType : int {
  GATE_HEAVEN = 0,
  GATE_HELL = 1,
  GateType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GateType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GateType_IsValid(int value);
constexpr GateType GateType_MIN = GATE_HEAVEN;
constexpr GateType GateType_MAX = GATE_HELL;
constexpr int GateType_ARRAYSIZE = GateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GateType_descriptor();
template<typename T>
inline const std::string& GateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GateType_descriptor(), enum_t_value);
}
inline bool GateType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GateType>(
    GateType_descriptor(), name, value);
}
enum GateDirection : int {
  GATE_DIRECTION_UP = 0,
  GATE_DIRECTION_DOWN = 1,
  GATE_DIRECTION_LEFT = 2,
  GATE_DIRECTION_RIGHT = 3,
  GateDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GateDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GateDirection_IsValid(int value);
constexpr GateDirection GateDirection_MIN = GATE_DIRECTION_UP;
constexpr GateDirection GateDirection_MAX = GATE_DIRECTION_RIGHT;
constexpr int GateDirection_ARRAYSIZE = GateDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GateDirection_descriptor();
template<typename T>
inline const std::string& GateDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GateDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GateDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GateDirection_descriptor(), enum_t_value);
}
inline bool GateDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GateDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GateDirection>(
    GateDirection_descriptor(), name, value);
}
// ===================================================================

class HelloMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.HelloMessage) */ {
 public:
  inline HelloMessage() : HelloMessage(nullptr) {}
  ~HelloMessage() override;
  explicit constexpr HelloMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HelloMessage(const HelloMessage& from);
  HelloMessage(HelloMessage&& from) noexcept
    : HelloMessage() {
    *this = ::std::move(from);
  }

  inline HelloMessage& operator=(const HelloMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloMessage& operator=(HelloMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelloMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelloMessage* internal_default_instance() {
    return reinterpret_cast<const HelloMessage*>(
               &_HelloMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HelloMessage& a, HelloMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HelloMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HelloMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HelloMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HelloMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.HelloMessage";
  }
  protected:
  explicit HelloMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIdFieldNumber = 1,
  };
  // int32 room_id = 1;
  void clear_room_id();
  int32_t room_id() const;
  void set_room_id(int32_t value);
  private:
  int32_t _internal_room_id() const;
  void _internal_set_room_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.HelloMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t room_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class Character final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.Character) */ {
 public:
  inline Character() : Character(nullptr) {}
  ~Character() override;
  explicit constexpr Character(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Character(const Character& from);
  Character(Character&& from) noexcept
    : Character() {
    *this = ::std::move(from);
  }

  inline Character& operator=(const Character& from) {
    CopyFrom(from);
    return *this;
  }
  inline Character& operator=(Character&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Character& default_instance() {
    return *internal_default_instance();
  }
  static inline const Character* internal_default_instance() {
    return reinterpret_cast<const Character*>(
               &_Character_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Character& a, Character& b) {
    a.Swap(&b);
  }
  inline void Swap(Character* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Character* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Character* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Character>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Character& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Character& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Character* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.Character";
  }
  protected:
  explicit Character(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kCharacterTypeFieldNumber = 2,
  };
  // int32 player_id = 1;
  void clear_player_id();
  int32_t player_id() const;
  void set_player_id(int32_t value);
  private:
  int32_t _internal_player_id() const;
  void _internal_set_player_id(int32_t value);
  public:

  // .message.CharacterType character_type = 2;
  void clear_character_type();
  ::message::CharacterType character_type() const;
  void set_character_type(::message::CharacterType value);
  private:
  ::message::CharacterType _internal_character_type() const;
  void _internal_set_character_type(::message::CharacterType value);
  public:

  // @@protoc_insertion_point(class_scope:message.Character)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t player_id_;
  int character_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class MessageWrapper final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.MessageWrapper) */ {
 public:
  inline MessageWrapper() : MessageWrapper(nullptr) {}
  ~MessageWrapper() override;
  explicit constexpr MessageWrapper(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageWrapper(const MessageWrapper& from);
  MessageWrapper(MessageWrapper&& from) noexcept
    : MessageWrapper() {
    *this = ::std::move(from);
  }

  inline MessageWrapper& operator=(const MessageWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageWrapper& operator=(MessageWrapper&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageWrapper& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kRoomMessage = 1,
    kStringMessage = 2,
    kLobbyMessage = 3,
    kStartReceiveMsgMessage = 4,
    kPlayerBasicMessage = 5,
    kPropTryGetMessage = 6,
    kPropGetMessage = 7,
    kIntegerMessage = 8,
    kGateMessage = 9,
    kEnterGateMessage = 10,
    kEnterGateResultMessage = 11,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const MessageWrapper* internal_default_instance() {
    return reinterpret_cast<const MessageWrapper*>(
               &_MessageWrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MessageWrapper& a, MessageWrapper& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageWrapper* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageWrapper* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageWrapper* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageWrapper>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageWrapper& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MessageWrapper& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageWrapper* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.MessageWrapper";
  }
  protected:
  explicit MessageWrapper(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomMessageFieldNumber = 1,
    kStringMessageFieldNumber = 2,
    kLobbyMessageFieldNumber = 3,
    kStartReceiveMsgMessageFieldNumber = 4,
    kPlayerBasicMessageFieldNumber = 5,
    kPropTryGetMessageFieldNumber = 6,
    kPropGetMessageFieldNumber = 7,
    kIntegerMessageFieldNumber = 8,
    kGateMessageFieldNumber = 9,
    kEnterGateMessageFieldNumber = 10,
    kEnterGateResultMessageFieldNumber = 11,
  };
  // .message.RoomMessage room_message = 1;
  bool has_room_message() const;
  private:
  bool _internal_has_room_message() const;
  public:
  void clear_room_message();
  const ::message::RoomMessage& room_message() const;
  PROTOBUF_NODISCARD ::message::RoomMessage* release_room_message();
  ::message::RoomMessage* mutable_room_message();
  void set_allocated_room_message(::message::RoomMessage* room_message);
  private:
  const ::message::RoomMessage& _internal_room_message() const;
  ::message::RoomMessage* _internal_mutable_room_message();
  public:
  void unsafe_arena_set_allocated_room_message(
      ::message::RoomMessage* room_message);
  ::message::RoomMessage* unsafe_arena_release_room_message();

  // .message.StringMessage string_message = 2;
  bool has_string_message() const;
  private:
  bool _internal_has_string_message() const;
  public:
  void clear_string_message();
  const ::message::StringMessage& string_message() const;
  PROTOBUF_NODISCARD ::message::StringMessage* release_string_message();
  ::message::StringMessage* mutable_string_message();
  void set_allocated_string_message(::message::StringMessage* string_message);
  private:
  const ::message::StringMessage& _internal_string_message() const;
  ::message::StringMessage* _internal_mutable_string_message();
  public:
  void unsafe_arena_set_allocated_string_message(
      ::message::StringMessage* string_message);
  ::message::StringMessage* unsafe_arena_release_string_message();

  // .message.LobbyMessage lobby_message = 3;
  bool has_lobby_message() const;
  private:
  bool _internal_has_lobby_message() const;
  public:
  void clear_lobby_message();
  const ::message::LobbyMessage& lobby_message() const;
  PROTOBUF_NODISCARD ::message::LobbyMessage* release_lobby_message();
  ::message::LobbyMessage* mutable_lobby_message();
  void set_allocated_lobby_message(::message::LobbyMessage* lobby_message);
  private:
  const ::message::LobbyMessage& _internal_lobby_message() const;
  ::message::LobbyMessage* _internal_mutable_lobby_message();
  public:
  void unsafe_arena_set_allocated_lobby_message(
      ::message::LobbyMessage* lobby_message);
  ::message::LobbyMessage* unsafe_arena_release_lobby_message();

  // .message.StartReceiveMsgMessage start_receive_msg_message = 4;
  bool has_start_receive_msg_message() const;
  private:
  bool _internal_has_start_receive_msg_message() const;
  public:
  void clear_start_receive_msg_message();
  const ::message::StartReceiveMsgMessage& start_receive_msg_message() const;
  PROTOBUF_NODISCARD ::message::StartReceiveMsgMessage* release_start_receive_msg_message();
  ::message::StartReceiveMsgMessage* mutable_start_receive_msg_message();
  void set_allocated_start_receive_msg_message(::message::StartReceiveMsgMessage* start_receive_msg_message);
  private:
  const ::message::StartReceiveMsgMessage& _internal_start_receive_msg_message() const;
  ::message::StartReceiveMsgMessage* _internal_mutable_start_receive_msg_message();
  public:
  void unsafe_arena_set_allocated_start_receive_msg_message(
      ::message::StartReceiveMsgMessage* start_receive_msg_message);
  ::message::StartReceiveMsgMessage* unsafe_arena_release_start_receive_msg_message();

  // .message.PlayerBasicMessage player_basic_message = 5;
  bool has_player_basic_message() const;
  private:
  bool _internal_has_player_basic_message() const;
  public:
  void clear_player_basic_message();
  const ::message::PlayerBasicMessage& player_basic_message() const;
  PROTOBUF_NODISCARD ::message::PlayerBasicMessage* release_player_basic_message();
  ::message::PlayerBasicMessage* mutable_player_basic_message();
  void set_allocated_player_basic_message(::message::PlayerBasicMessage* player_basic_message);
  private:
  const ::message::PlayerBasicMessage& _internal_player_basic_message() const;
  ::message::PlayerBasicMessage* _internal_mutable_player_basic_message();
  public:
  void unsafe_arena_set_allocated_player_basic_message(
      ::message::PlayerBasicMessage* player_basic_message);
  ::message::PlayerBasicMessage* unsafe_arena_release_player_basic_message();

  // .message.PropTryGetMessage prop_try_get_message = 6;
  bool has_prop_try_get_message() const;
  private:
  bool _internal_has_prop_try_get_message() const;
  public:
  void clear_prop_try_get_message();
  const ::message::PropTryGetMessage& prop_try_get_message() const;
  PROTOBUF_NODISCARD ::message::PropTryGetMessage* release_prop_try_get_message();
  ::message::PropTryGetMessage* mutable_prop_try_get_message();
  void set_allocated_prop_try_get_message(::message::PropTryGetMessage* prop_try_get_message);
  private:
  const ::message::PropTryGetMessage& _internal_prop_try_get_message() const;
  ::message::PropTryGetMessage* _internal_mutable_prop_try_get_message();
  public:
  void unsafe_arena_set_allocated_prop_try_get_message(
      ::message::PropTryGetMessage* prop_try_get_message);
  ::message::PropTryGetMessage* unsafe_arena_release_prop_try_get_message();

  // .message.PropGetMessage prop_get_message = 7;
  bool has_prop_get_message() const;
  private:
  bool _internal_has_prop_get_message() const;
  public:
  void clear_prop_get_message();
  const ::message::PropGetMessage& prop_get_message() const;
  PROTOBUF_NODISCARD ::message::PropGetMessage* release_prop_get_message();
  ::message::PropGetMessage* mutable_prop_get_message();
  void set_allocated_prop_get_message(::message::PropGetMessage* prop_get_message);
  private:
  const ::message::PropGetMessage& _internal_prop_get_message() const;
  ::message::PropGetMessage* _internal_mutable_prop_get_message();
  public:
  void unsafe_arena_set_allocated_prop_get_message(
      ::message::PropGetMessage* prop_get_message);
  ::message::PropGetMessage* unsafe_arena_release_prop_get_message();

  // .message.IntegerMessage integer_message = 8;
  bool has_integer_message() const;
  private:
  bool _internal_has_integer_message() const;
  public:
  void clear_integer_message();
  const ::message::IntegerMessage& integer_message() const;
  PROTOBUF_NODISCARD ::message::IntegerMessage* release_integer_message();
  ::message::IntegerMessage* mutable_integer_message();
  void set_allocated_integer_message(::message::IntegerMessage* integer_message);
  private:
  const ::message::IntegerMessage& _internal_integer_message() const;
  ::message::IntegerMessage* _internal_mutable_integer_message();
  public:
  void unsafe_arena_set_allocated_integer_message(
      ::message::IntegerMessage* integer_message);
  ::message::IntegerMessage* unsafe_arena_release_integer_message();

  // .message.GateMessage gate_message = 9;
  bool has_gate_message() const;
  private:
  bool _internal_has_gate_message() const;
  public:
  void clear_gate_message();
  const ::message::GateMessage& gate_message() const;
  PROTOBUF_NODISCARD ::message::GateMessage* release_gate_message();
  ::message::GateMessage* mutable_gate_message();
  void set_allocated_gate_message(::message::GateMessage* gate_message);
  private:
  const ::message::GateMessage& _internal_gate_message() const;
  ::message::GateMessage* _internal_mutable_gate_message();
  public:
  void unsafe_arena_set_allocated_gate_message(
      ::message::GateMessage* gate_message);
  ::message::GateMessage* unsafe_arena_release_gate_message();

  // .message.EnterGateMessage enter_gate_message = 10;
  bool has_enter_gate_message() const;
  private:
  bool _internal_has_enter_gate_message() const;
  public:
  void clear_enter_gate_message();
  const ::message::EnterGateMessage& enter_gate_message() const;
  PROTOBUF_NODISCARD ::message::EnterGateMessage* release_enter_gate_message();
  ::message::EnterGateMessage* mutable_enter_gate_message();
  void set_allocated_enter_gate_message(::message::EnterGateMessage* enter_gate_message);
  private:
  const ::message::EnterGateMessage& _internal_enter_gate_message() const;
  ::message::EnterGateMessage* _internal_mutable_enter_gate_message();
  public:
  void unsafe_arena_set_allocated_enter_gate_message(
      ::message::EnterGateMessage* enter_gate_message);
  ::message::EnterGateMessage* unsafe_arena_release_enter_gate_message();

  // .message.EnterGateResultMessage enter_gate_result_message = 11;
  bool has_enter_gate_result_message() const;
  private:
  bool _internal_has_enter_gate_result_message() const;
  public:
  void clear_enter_gate_result_message();
  const ::message::EnterGateResultMessage& enter_gate_result_message() const;
  PROTOBUF_NODISCARD ::message::EnterGateResultMessage* release_enter_gate_result_message();
  ::message::EnterGateResultMessage* mutable_enter_gate_result_message();
  void set_allocated_enter_gate_result_message(::message::EnterGateResultMessage* enter_gate_result_message);
  private:
  const ::message::EnterGateResultMessage& _internal_enter_gate_result_message() const;
  ::message::EnterGateResultMessage* _internal_mutable_enter_gate_result_message();
  public:
  void unsafe_arena_set_allocated_enter_gate_result_message(
      ::message::EnterGateResultMessage* enter_gate_result_message);
  ::message::EnterGateResultMessage* unsafe_arena_release_enter_gate_result_message();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:message.MessageWrapper)
 private:
  class _Internal;
  void set_has_room_message();
  void set_has_string_message();
  void set_has_lobby_message();
  void set_has_start_receive_msg_message();
  void set_has_player_basic_message();
  void set_has_prop_try_get_message();
  void set_has_prop_get_message();
  void set_has_integer_message();
  void set_has_gate_message();
  void set_has_enter_gate_message();
  void set_has_enter_gate_result_message();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union PayloadUnion {
    constexpr PayloadUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::message::RoomMessage* room_message_;
    ::message::StringMessage* string_message_;
    ::message::LobbyMessage* lobby_message_;
    ::message::StartReceiveMsgMessage* start_receive_msg_message_;
    ::message::PlayerBasicMessage* player_basic_message_;
    ::message::PropTryGetMessage* prop_try_get_message_;
    ::message::PropGetMessage* prop_get_message_;
    ::message::IntegerMessage* integer_message_;
    ::message::GateMessage* gate_message_;
    ::message::EnterGateMessage* enter_gate_message_;
    ::message::EnterGateResultMessage* enter_gate_result_message_;
  } payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class RoomMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.RoomMessage) */ {
 public:
  inline RoomMessage() : RoomMessage(nullptr) {}
  ~RoomMessage() override;
  explicit constexpr RoomMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomMessage(const RoomMessage& from);
  RoomMessage(RoomMessage&& from) noexcept
    : RoomMessage() {
    *this = ::std::move(from);
  }

  inline RoomMessage& operator=(const RoomMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomMessage& operator=(RoomMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomMessage* internal_default_instance() {
    return reinterpret_cast<const RoomMessage*>(
               &_RoomMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RoomMessage& a, RoomMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoomMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.RoomMessage";
  }
  protected:
  explicit RoomMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharactersFieldNumber = 4,
    kIsJoinFieldNumber = 1,
    kRoomIdFieldNumber = 2,
    kPlayerIdFieldNumber = 3,
  };
  // repeated .message.Character characters = 4;
  int characters_size() const;
  private:
  int _internal_characters_size() const;
  public:
  void clear_characters();
  ::message::Character* mutable_characters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::Character >*
      mutable_characters();
  private:
  const ::message::Character& _internal_characters(int index) const;
  ::message::Character* _internal_add_characters();
  public:
  const ::message::Character& characters(int index) const;
  ::message::Character* add_characters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::Character >&
      characters() const;

  // bool is_join = 1;
  void clear_is_join();
  bool is_join() const;
  void set_is_join(bool value);
  private:
  bool _internal_is_join() const;
  void _internal_set_is_join(bool value);
  public:

  // int32 room_id = 2;
  void clear_room_id();
  int32_t room_id() const;
  void set_room_id(int32_t value);
  private:
  int32_t _internal_room_id() const;
  void _internal_set_room_id(int32_t value);
  public:

  // int32 player_id = 3;
  void clear_player_id();
  int32_t player_id() const;
  void set_player_id(int32_t value);
  private:
  int32_t _internal_player_id() const;
  void _internal_set_player_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.RoomMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::Character > characters_;
  bool is_join_;
  int32_t room_id_;
  int32_t player_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class StringMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.StringMessage) */ {
 public:
  inline StringMessage() : StringMessage(nullptr) {}
  ~StringMessage() override;
  explicit constexpr StringMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StringMessage(const StringMessage& from);
  StringMessage(StringMessage&& from) noexcept
    : StringMessage() {
    *this = ::std::move(from);
  }

  inline StringMessage& operator=(const StringMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringMessage& operator=(StringMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringMessage* internal_default_instance() {
    return reinterpret_cast<const StringMessage*>(
               &_StringMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StringMessage& a, StringMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(StringMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StringMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StringMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.StringMessage";
  }
  protected:
  explicit StringMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageContentFieldNumber = 2,
    kMessageTypeFieldNumber = 1,
  };
  // string message_content = 2;
  void clear_message_content();
  const std::string& message_content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_content();
  PROTOBUF_NODISCARD std::string* release_message_content();
  void set_allocated_message_content(std::string* message_content);
  private:
  const std::string& _internal_message_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_content(const std::string& value);
  std::string* _internal_mutable_message_content();
  public:

  // int32 message_type = 1;
  void clear_message_type();
  int32_t message_type() const;
  void set_message_type(int32_t value);
  private:
  int32_t _internal_message_type() const;
  void _internal_set_message_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.StringMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_content_;
  int32_t message_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class LobbyMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.LobbyMessage) */ {
 public:
  inline LobbyMessage() : LobbyMessage(nullptr) {}
  ~LobbyMessage() override;
  explicit constexpr LobbyMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LobbyMessage(const LobbyMessage& from);
  LobbyMessage(LobbyMessage&& from) noexcept
    : LobbyMessage() {
    *this = ::std::move(from);
  }

  inline LobbyMessage& operator=(const LobbyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline LobbyMessage& operator=(LobbyMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LobbyMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const LobbyMessage* internal_default_instance() {
    return reinterpret_cast<const LobbyMessage*>(
               &_LobbyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LobbyMessage& a, LobbyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(LobbyMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LobbyMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LobbyMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LobbyMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LobbyMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LobbyMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LobbyMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.LobbyMessage";
  }
  protected:
  explicit LobbyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsReadyFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
    kCharacterTypeFieldNumber = 3,
  };
  // bool is_ready = 1;
  void clear_is_ready();
  bool is_ready() const;
  void set_is_ready(bool value);
  private:
  bool _internal_is_ready() const;
  void _internal_set_is_ready(bool value);
  public:

  // int32 player_id = 2;
  void clear_player_id();
  int32_t player_id() const;
  void set_player_id(int32_t value);
  private:
  int32_t _internal_player_id() const;
  void _internal_set_player_id(int32_t value);
  public:

  // .message.CharacterType character_type = 3;
  void clear_character_type();
  ::message::CharacterType character_type() const;
  void set_character_type(::message::CharacterType value);
  private:
  ::message::CharacterType _internal_character_type() const;
  void _internal_set_character_type(::message::CharacterType value);
  public:

  // @@protoc_insertion_point(class_scope:message.LobbyMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool is_ready_;
  int32_t player_id_;
  int character_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class StartReceiveMsgMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.StartReceiveMsgMessage) */ {
 public:
  inline StartReceiveMsgMessage() : StartReceiveMsgMessage(nullptr) {}
  ~StartReceiveMsgMessage() override;
  explicit constexpr StartReceiveMsgMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartReceiveMsgMessage(const StartReceiveMsgMessage& from);
  StartReceiveMsgMessage(StartReceiveMsgMessage&& from) noexcept
    : StartReceiveMsgMessage() {
    *this = ::std::move(from);
  }

  inline StartReceiveMsgMessage& operator=(const StartReceiveMsgMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartReceiveMsgMessage& operator=(StartReceiveMsgMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartReceiveMsgMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartReceiveMsgMessage* internal_default_instance() {
    return reinterpret_cast<const StartReceiveMsgMessage*>(
               &_StartReceiveMsgMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StartReceiveMsgMessage& a, StartReceiveMsgMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(StartReceiveMsgMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartReceiveMsgMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartReceiveMsgMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartReceiveMsgMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartReceiveMsgMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StartReceiveMsgMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartReceiveMsgMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.StartReceiveMsgMessage";
  }
  protected:
  explicit StartReceiveMsgMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // int32 player_id = 1;
  void clear_player_id();
  int32_t player_id() const;
  void set_player_id(int32_t value);
  private:
  int32_t _internal_player_id() const;
  void _internal_set_player_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.StartReceiveMsgMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t player_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class PlayerBasicMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.PlayerBasicMessage) */ {
 public:
  inline PlayerBasicMessage() : PlayerBasicMessage(nullptr) {}
  ~PlayerBasicMessage() override;
  explicit constexpr PlayerBasicMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerBasicMessage(const PlayerBasicMessage& from);
  PlayerBasicMessage(PlayerBasicMessage&& from) noexcept
    : PlayerBasicMessage() {
    *this = ::std::move(from);
  }

  inline PlayerBasicMessage& operator=(const PlayerBasicMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerBasicMessage& operator=(PlayerBasicMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerBasicMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerBasicMessage* internal_default_instance() {
    return reinterpret_cast<const PlayerBasicMessage*>(
               &_PlayerBasicMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PlayerBasicMessage& a, PlayerBasicMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerBasicMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerBasicMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerBasicMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerBasicMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerBasicMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerBasicMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerBasicMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.PlayerBasicMessage";
  }
  protected:
  explicit PlayerBasicMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kPositionXFieldNumber = 2,
    kPositionYFieldNumber = 3,
    kHpFieldNumber = 4,
    kMaxHpFieldNumber = 5,
    kAnimationTypeFieldNumber = 6,
    kCharacterStateFieldNumber = 7,
  };
  // int32 player_id = 1;
  void clear_player_id();
  int32_t player_id() const;
  void set_player_id(int32_t value);
  private:
  int32_t _internal_player_id() const;
  void _internal_set_player_id(int32_t value);
  public:

  // float position_x = 2;
  void clear_position_x();
  float position_x() const;
  void set_position_x(float value);
  private:
  float _internal_position_x() const;
  void _internal_set_position_x(float value);
  public:

  // float position_y = 3;
  void clear_position_y();
  float position_y() const;
  void set_position_y(float value);
  private:
  float _internal_position_y() const;
  void _internal_set_position_y(float value);
  public:

  // float hp = 4;
  void clear_hp();
  float hp() const;
  void set_hp(float value);
  private:
  float _internal_hp() const;
  void _internal_set_hp(float value);
  public:

  // float max_hp = 5;
  void clear_max_hp();
  float max_hp() const;
  void set_max_hp(float value);
  private:
  float _internal_max_hp() const;
  void _internal_set_max_hp(float value);
  public:

  // .message.PlayerAnimationType animation_type = 6;
  void clear_animation_type();
  ::message::PlayerAnimationType animation_type() const;
  void set_animation_type(::message::PlayerAnimationType value);
  private:
  ::message::PlayerAnimationType _internal_animation_type() const;
  void _internal_set_animation_type(::message::PlayerAnimationType value);
  public:

  // .message.CharacterState character_state = 7;
  void clear_character_state();
  ::message::CharacterState character_state() const;
  void set_character_state(::message::CharacterState value);
  private:
  ::message::CharacterState _internal_character_state() const;
  void _internal_set_character_state(::message::CharacterState value);
  public:

  // @@protoc_insertion_point(class_scope:message.PlayerBasicMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t player_id_;
  float position_x_;
  float position_y_;
  float hp_;
  float max_hp_;
  int animation_type_;
  int character_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class PropTryGetMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.PropTryGetMessage) */ {
 public:
  inline PropTryGetMessage() : PropTryGetMessage(nullptr) {}
  ~PropTryGetMessage() override;
  explicit constexpr PropTryGetMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PropTryGetMessage(const PropTryGetMessage& from);
  PropTryGetMessage(PropTryGetMessage&& from) noexcept
    : PropTryGetMessage() {
    *this = ::std::move(from);
  }

  inline PropTryGetMessage& operator=(const PropTryGetMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PropTryGetMessage& operator=(PropTryGetMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PropTryGetMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PropTryGetMessage* internal_default_instance() {
    return reinterpret_cast<const PropTryGetMessage*>(
               &_PropTryGetMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PropTryGetMessage& a, PropTryGetMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PropTryGetMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PropTryGetMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PropTryGetMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PropTryGetMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PropTryGetMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PropTryGetMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PropTryGetMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.PropTryGetMessage";
  }
  protected:
  explicit PropTryGetMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kPropIdFieldNumber = 2,
    kPropTypeFieldNumber = 3,
  };
  // int32 player_id = 1;
  void clear_player_id();
  int32_t player_id() const;
  void set_player_id(int32_t value);
  private:
  int32_t _internal_player_id() const;
  void _internal_set_player_id(int32_t value);
  public:

  // int32 prop_id = 2;
  void clear_prop_id();
  int32_t prop_id() const;
  void set_prop_id(int32_t value);
  private:
  int32_t _internal_prop_id() const;
  void _internal_set_prop_id(int32_t value);
  public:

  // int32 prop_type = 3;
  void clear_prop_type();
  int32_t prop_type() const;
  void set_prop_type(int32_t value);
  private:
  int32_t _internal_prop_type() const;
  void _internal_set_prop_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.PropTryGetMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t player_id_;
  int32_t prop_id_;
  int32_t prop_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class PropGetMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.PropGetMessage) */ {
 public:
  inline PropGetMessage() : PropGetMessage(nullptr) {}
  ~PropGetMessage() override;
  explicit constexpr PropGetMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PropGetMessage(const PropGetMessage& from);
  PropGetMessage(PropGetMessage&& from) noexcept
    : PropGetMessage() {
    *this = ::std::move(from);
  }

  inline PropGetMessage& operator=(const PropGetMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PropGetMessage& operator=(PropGetMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PropGetMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PropGetMessage* internal_default_instance() {
    return reinterpret_cast<const PropGetMessage*>(
               &_PropGetMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PropGetMessage& a, PropGetMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PropGetMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PropGetMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PropGetMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PropGetMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PropGetMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PropGetMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PropGetMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.PropGetMessage";
  }
  protected:
  explicit PropGetMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsGetFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
    kPropIdFieldNumber = 3,
  };
  // bool is_get = 1;
  void clear_is_get();
  bool is_get() const;
  void set_is_get(bool value);
  private:
  bool _internal_is_get() const;
  void _internal_set_is_get(bool value);
  public:

  // int32 player_id = 2;
  void clear_player_id();
  int32_t player_id() const;
  void set_player_id(int32_t value);
  private:
  int32_t _internal_player_id() const;
  void _internal_set_player_id(int32_t value);
  public:

  // int32 prop_id = 3;
  void clear_prop_id();
  int32_t prop_id() const;
  void set_prop_id(int32_t value);
  private:
  int32_t _internal_prop_id() const;
  void _internal_set_prop_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.PropGetMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool is_get_;
  int32_t player_id_;
  int32_t prop_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class IntegerMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.IntegerMessage) */ {
 public:
  inline IntegerMessage() : IntegerMessage(nullptr) {}
  ~IntegerMessage() override;
  explicit constexpr IntegerMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntegerMessage(const IntegerMessage& from);
  IntegerMessage(IntegerMessage&& from) noexcept
    : IntegerMessage() {
    *this = ::std::move(from);
  }

  inline IntegerMessage& operator=(const IntegerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntegerMessage& operator=(IntegerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntegerMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntegerMessage* internal_default_instance() {
    return reinterpret_cast<const IntegerMessage*>(
               &_IntegerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(IntegerMessage& a, IntegerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(IntegerMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntegerMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntegerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntegerMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntegerMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IntegerMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntegerMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.IntegerMessage";
  }
  protected:
  explicit IntegerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageTypeFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // .message.IntegerMessageType message_type = 1;
  void clear_message_type();
  ::message::IntegerMessageType message_type() const;
  void set_message_type(::message::IntegerMessageType value);
  private:
  ::message::IntegerMessageType _internal_message_type() const;
  void _internal_set_message_type(::message::IntegerMessageType value);
  public:

  // int32 value = 2;
  void clear_value();
  int32_t value() const;
  void set_value(int32_t value);
  private:
  int32_t _internal_value() const;
  void _internal_set_value(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.IntegerMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int message_type_;
  int32_t value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class Gate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.Gate) */ {
 public:
  inline Gate() : Gate(nullptr) {}
  ~Gate() override;
  explicit constexpr Gate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Gate(const Gate& from);
  Gate(Gate&& from) noexcept
    : Gate() {
    *this = ::std::move(from);
  }

  inline Gate& operator=(const Gate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Gate& operator=(Gate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Gate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Gate* internal_default_instance() {
    return reinterpret_cast<const Gate*>(
               &_Gate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Gate& a, Gate& b) {
    a.Swap(&b);
  }
  inline void Swap(Gate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Gate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Gate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Gate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Gate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Gate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Gate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.Gate";
  }
  protected:
  explicit Gate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGateDirectionFieldNumber = 1,
    kGateTypeFieldNumber = 2,
  };
  // .message.GateDirection gate_direction = 1;
  void clear_gate_direction();
  ::message::GateDirection gate_direction() const;
  void set_gate_direction(::message::GateDirection value);
  private:
  ::message::GateDirection _internal_gate_direction() const;
  void _internal_set_gate_direction(::message::GateDirection value);
  public:

  // .message.GateType gate_type = 2;
  void clear_gate_type();
  ::message::GateType gate_type() const;
  void set_gate_type(::message::GateType value);
  private:
  ::message::GateType _internal_gate_type() const;
  void _internal_set_gate_type(::message::GateType value);
  public:

  // @@protoc_insertion_point(class_scope:message.Gate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int gate_direction_;
  int gate_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class GateMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.GateMessage) */ {
 public:
  inline GateMessage() : GateMessage(nullptr) {}
  ~GateMessage() override;
  explicit constexpr GateMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GateMessage(const GateMessage& from);
  GateMessage(GateMessage&& from) noexcept
    : GateMessage() {
    *this = ::std::move(from);
  }

  inline GateMessage& operator=(const GateMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GateMessage& operator=(GateMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GateMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const GateMessage* internal_default_instance() {
    return reinterpret_cast<const GateMessage*>(
               &_GateMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GateMessage& a, GateMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GateMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GateMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GateMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GateMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GateMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GateMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GateMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.GateMessage";
  }
  protected:
  explicit GateMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGatesFieldNumber = 1,
  };
  // repeated .message.Gate gates = 1;
  int gates_size() const;
  private:
  int _internal_gates_size() const;
  public:
  void clear_gates();
  ::message::Gate* mutable_gates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::Gate >*
      mutable_gates();
  private:
  const ::message::Gate& _internal_gates(int index) const;
  ::message::Gate* _internal_add_gates();
  public:
  const ::message::Gate& gates(int index) const;
  ::message::Gate* add_gates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::Gate >&
      gates() const;

  // @@protoc_insertion_point(class_scope:message.GateMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::Gate > gates_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class EnterGateMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.EnterGateMessage) */ {
 public:
  inline EnterGateMessage() : EnterGateMessage(nullptr) {}
  ~EnterGateMessage() override;
  explicit constexpr EnterGateMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnterGateMessage(const EnterGateMessage& from);
  EnterGateMessage(EnterGateMessage&& from) noexcept
    : EnterGateMessage() {
    *this = ::std::move(from);
  }

  inline EnterGateMessage& operator=(const EnterGateMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnterGateMessage& operator=(EnterGateMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnterGateMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnterGateMessage* internal_default_instance() {
    return reinterpret_cast<const EnterGateMessage*>(
               &_EnterGateMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(EnterGateMessage& a, EnterGateMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(EnterGateMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnterGateMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnterGateMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnterGateMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnterGateMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EnterGateMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnterGateMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.EnterGateMessage";
  }
  protected:
  explicit EnterGateMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGateDirectionFieldNumber = 2,
  };
  // .message.GateDirection gate_direction = 2;
  void clear_gate_direction();
  ::message::GateDirection gate_direction() const;
  void set_gate_direction(::message::GateDirection value);
  private:
  ::message::GateDirection _internal_gate_direction() const;
  void _internal_set_gate_direction(::message::GateDirection value);
  public:

  // @@protoc_insertion_point(class_scope:message.EnterGateMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int gate_direction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class EnterGateResultMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.EnterGateResultMessage) */ {
 public:
  inline EnterGateResultMessage() : EnterGateResultMessage(nullptr) {}
  ~EnterGateResultMessage() override;
  explicit constexpr EnterGateResultMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnterGateResultMessage(const EnterGateResultMessage& from);
  EnterGateResultMessage(EnterGateResultMessage&& from) noexcept
    : EnterGateResultMessage() {
    *this = ::std::move(from);
  }

  inline EnterGateResultMessage& operator=(const EnterGateResultMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnterGateResultMessage& operator=(EnterGateResultMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnterGateResultMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnterGateResultMessage* internal_default_instance() {
    return reinterpret_cast<const EnterGateResultMessage*>(
               &_EnterGateResultMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(EnterGateResultMessage& a, EnterGateResultMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(EnterGateResultMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnterGateResultMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnterGateResultMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnterGateResultMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnterGateResultMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EnterGateResultMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnterGateResultMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.EnterGateResultMessage";
  }
  protected:
  explicit EnterGateResultMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGateFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
  };
  // .message.Gate gate = 2;
  bool has_gate() const;
  private:
  bool _internal_has_gate() const;
  public:
  void clear_gate();
  const ::message::Gate& gate() const;
  PROTOBUF_NODISCARD ::message::Gate* release_gate();
  ::message::Gate* mutable_gate();
  void set_allocated_gate(::message::Gate* gate);
  private:
  const ::message::Gate& _internal_gate() const;
  ::message::Gate* _internal_mutable_gate();
  public:
  void unsafe_arena_set_allocated_gate(
      ::message::Gate* gate);
  ::message::Gate* unsafe_arena_release_gate();

  // int32 player_id = 1;
  void clear_player_id();
  int32_t player_id() const;
  void set_player_id(int32_t value);
  private:
  int32_t _internal_player_id() const;
  void _internal_set_player_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.EnterGateResultMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::message::Gate* gate_;
  int32_t player_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HelloMessage

// int32 room_id = 1;
inline void HelloMessage::clear_room_id() {
  room_id_ = 0;
}
inline int32_t HelloMessage::_internal_room_id() const {
  return room_id_;
}
inline int32_t HelloMessage::room_id() const {
  // @@protoc_insertion_point(field_get:message.HelloMessage.room_id)
  return _internal_room_id();
}
inline void HelloMessage::_internal_set_room_id(int32_t value) {
  
  room_id_ = value;
}
inline void HelloMessage::set_room_id(int32_t value) {
  _internal_set_room_id(value);
  // @@protoc_insertion_point(field_set:message.HelloMessage.room_id)
}

// -------------------------------------------------------------------

// Character

// int32 player_id = 1;
inline void Character::clear_player_id() {
  player_id_ = 0;
}
inline int32_t Character::_internal_player_id() const {
  return player_id_;
}
inline int32_t Character::player_id() const {
  // @@protoc_insertion_point(field_get:message.Character.player_id)
  return _internal_player_id();
}
inline void Character::_internal_set_player_id(int32_t value) {
  
  player_id_ = value;
}
inline void Character::set_player_id(int32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:message.Character.player_id)
}

// .message.CharacterType character_type = 2;
inline void Character::clear_character_type() {
  character_type_ = 0;
}
inline ::message::CharacterType Character::_internal_character_type() const {
  return static_cast< ::message::CharacterType >(character_type_);
}
inline ::message::CharacterType Character::character_type() const {
  // @@protoc_insertion_point(field_get:message.Character.character_type)
  return _internal_character_type();
}
inline void Character::_internal_set_character_type(::message::CharacterType value) {
  
  character_type_ = value;
}
inline void Character::set_character_type(::message::CharacterType value) {
  _internal_set_character_type(value);
  // @@protoc_insertion_point(field_set:message.Character.character_type)
}

// -------------------------------------------------------------------

// MessageWrapper

// .message.RoomMessage room_message = 1;
inline bool MessageWrapper::_internal_has_room_message() const {
  return payload_case() == kRoomMessage;
}
inline bool MessageWrapper::has_room_message() const {
  return _internal_has_room_message();
}
inline void MessageWrapper::set_has_room_message() {
  _oneof_case_[0] = kRoomMessage;
}
inline void MessageWrapper::clear_room_message() {
  if (_internal_has_room_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.room_message_;
    }
    clear_has_payload();
  }
}
inline ::message::RoomMessage* MessageWrapper::release_room_message() {
  // @@protoc_insertion_point(field_release:message.MessageWrapper.room_message)
  if (_internal_has_room_message()) {
    clear_has_payload();
      ::message::RoomMessage* temp = payload_.room_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.room_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::RoomMessage& MessageWrapper::_internal_room_message() const {
  return _internal_has_room_message()
      ? *payload_.room_message_
      : reinterpret_cast< ::message::RoomMessage&>(::message::_RoomMessage_default_instance_);
}
inline const ::message::RoomMessage& MessageWrapper::room_message() const {
  // @@protoc_insertion_point(field_get:message.MessageWrapper.room_message)
  return _internal_room_message();
}
inline ::message::RoomMessage* MessageWrapper::unsafe_arena_release_room_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageWrapper.room_message)
  if (_internal_has_room_message()) {
    clear_has_payload();
    ::message::RoomMessage* temp = payload_.room_message_;
    payload_.room_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageWrapper::unsafe_arena_set_allocated_room_message(::message::RoomMessage* room_message) {
  clear_payload();
  if (room_message) {
    set_has_room_message();
    payload_.room_message_ = room_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageWrapper.room_message)
}
inline ::message::RoomMessage* MessageWrapper::_internal_mutable_room_message() {
  if (!_internal_has_room_message()) {
    clear_payload();
    set_has_room_message();
    payload_.room_message_ = CreateMaybeMessage< ::message::RoomMessage >(GetArenaForAllocation());
  }
  return payload_.room_message_;
}
inline ::message::RoomMessage* MessageWrapper::mutable_room_message() {
  ::message::RoomMessage* _msg = _internal_mutable_room_message();
  // @@protoc_insertion_point(field_mutable:message.MessageWrapper.room_message)
  return _msg;
}

// .message.StringMessage string_message = 2;
inline bool MessageWrapper::_internal_has_string_message() const {
  return payload_case() == kStringMessage;
}
inline bool MessageWrapper::has_string_message() const {
  return _internal_has_string_message();
}
inline void MessageWrapper::set_has_string_message() {
  _oneof_case_[0] = kStringMessage;
}
inline void MessageWrapper::clear_string_message() {
  if (_internal_has_string_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.string_message_;
    }
    clear_has_payload();
  }
}
inline ::message::StringMessage* MessageWrapper::release_string_message() {
  // @@protoc_insertion_point(field_release:message.MessageWrapper.string_message)
  if (_internal_has_string_message()) {
    clear_has_payload();
      ::message::StringMessage* temp = payload_.string_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.string_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::StringMessage& MessageWrapper::_internal_string_message() const {
  return _internal_has_string_message()
      ? *payload_.string_message_
      : reinterpret_cast< ::message::StringMessage&>(::message::_StringMessage_default_instance_);
}
inline const ::message::StringMessage& MessageWrapper::string_message() const {
  // @@protoc_insertion_point(field_get:message.MessageWrapper.string_message)
  return _internal_string_message();
}
inline ::message::StringMessage* MessageWrapper::unsafe_arena_release_string_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageWrapper.string_message)
  if (_internal_has_string_message()) {
    clear_has_payload();
    ::message::StringMessage* temp = payload_.string_message_;
    payload_.string_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageWrapper::unsafe_arena_set_allocated_string_message(::message::StringMessage* string_message) {
  clear_payload();
  if (string_message) {
    set_has_string_message();
    payload_.string_message_ = string_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageWrapper.string_message)
}
inline ::message::StringMessage* MessageWrapper::_internal_mutable_string_message() {
  if (!_internal_has_string_message()) {
    clear_payload();
    set_has_string_message();
    payload_.string_message_ = CreateMaybeMessage< ::message::StringMessage >(GetArenaForAllocation());
  }
  return payload_.string_message_;
}
inline ::message::StringMessage* MessageWrapper::mutable_string_message() {
  ::message::StringMessage* _msg = _internal_mutable_string_message();
  // @@protoc_insertion_point(field_mutable:message.MessageWrapper.string_message)
  return _msg;
}

// .message.LobbyMessage lobby_message = 3;
inline bool MessageWrapper::_internal_has_lobby_message() const {
  return payload_case() == kLobbyMessage;
}
inline bool MessageWrapper::has_lobby_message() const {
  return _internal_has_lobby_message();
}
inline void MessageWrapper::set_has_lobby_message() {
  _oneof_case_[0] = kLobbyMessage;
}
inline void MessageWrapper::clear_lobby_message() {
  if (_internal_has_lobby_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.lobby_message_;
    }
    clear_has_payload();
  }
}
inline ::message::LobbyMessage* MessageWrapper::release_lobby_message() {
  // @@protoc_insertion_point(field_release:message.MessageWrapper.lobby_message)
  if (_internal_has_lobby_message()) {
    clear_has_payload();
      ::message::LobbyMessage* temp = payload_.lobby_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.lobby_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::LobbyMessage& MessageWrapper::_internal_lobby_message() const {
  return _internal_has_lobby_message()
      ? *payload_.lobby_message_
      : reinterpret_cast< ::message::LobbyMessage&>(::message::_LobbyMessage_default_instance_);
}
inline const ::message::LobbyMessage& MessageWrapper::lobby_message() const {
  // @@protoc_insertion_point(field_get:message.MessageWrapper.lobby_message)
  return _internal_lobby_message();
}
inline ::message::LobbyMessage* MessageWrapper::unsafe_arena_release_lobby_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageWrapper.lobby_message)
  if (_internal_has_lobby_message()) {
    clear_has_payload();
    ::message::LobbyMessage* temp = payload_.lobby_message_;
    payload_.lobby_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageWrapper::unsafe_arena_set_allocated_lobby_message(::message::LobbyMessage* lobby_message) {
  clear_payload();
  if (lobby_message) {
    set_has_lobby_message();
    payload_.lobby_message_ = lobby_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageWrapper.lobby_message)
}
inline ::message::LobbyMessage* MessageWrapper::_internal_mutable_lobby_message() {
  if (!_internal_has_lobby_message()) {
    clear_payload();
    set_has_lobby_message();
    payload_.lobby_message_ = CreateMaybeMessage< ::message::LobbyMessage >(GetArenaForAllocation());
  }
  return payload_.lobby_message_;
}
inline ::message::LobbyMessage* MessageWrapper::mutable_lobby_message() {
  ::message::LobbyMessage* _msg = _internal_mutable_lobby_message();
  // @@protoc_insertion_point(field_mutable:message.MessageWrapper.lobby_message)
  return _msg;
}

// .message.StartReceiveMsgMessage start_receive_msg_message = 4;
inline bool MessageWrapper::_internal_has_start_receive_msg_message() const {
  return payload_case() == kStartReceiveMsgMessage;
}
inline bool MessageWrapper::has_start_receive_msg_message() const {
  return _internal_has_start_receive_msg_message();
}
inline void MessageWrapper::set_has_start_receive_msg_message() {
  _oneof_case_[0] = kStartReceiveMsgMessage;
}
inline void MessageWrapper::clear_start_receive_msg_message() {
  if (_internal_has_start_receive_msg_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.start_receive_msg_message_;
    }
    clear_has_payload();
  }
}
inline ::message::StartReceiveMsgMessage* MessageWrapper::release_start_receive_msg_message() {
  // @@protoc_insertion_point(field_release:message.MessageWrapper.start_receive_msg_message)
  if (_internal_has_start_receive_msg_message()) {
    clear_has_payload();
      ::message::StartReceiveMsgMessage* temp = payload_.start_receive_msg_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.start_receive_msg_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::StartReceiveMsgMessage& MessageWrapper::_internal_start_receive_msg_message() const {
  return _internal_has_start_receive_msg_message()
      ? *payload_.start_receive_msg_message_
      : reinterpret_cast< ::message::StartReceiveMsgMessage&>(::message::_StartReceiveMsgMessage_default_instance_);
}
inline const ::message::StartReceiveMsgMessage& MessageWrapper::start_receive_msg_message() const {
  // @@protoc_insertion_point(field_get:message.MessageWrapper.start_receive_msg_message)
  return _internal_start_receive_msg_message();
}
inline ::message::StartReceiveMsgMessage* MessageWrapper::unsafe_arena_release_start_receive_msg_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageWrapper.start_receive_msg_message)
  if (_internal_has_start_receive_msg_message()) {
    clear_has_payload();
    ::message::StartReceiveMsgMessage* temp = payload_.start_receive_msg_message_;
    payload_.start_receive_msg_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageWrapper::unsafe_arena_set_allocated_start_receive_msg_message(::message::StartReceiveMsgMessage* start_receive_msg_message) {
  clear_payload();
  if (start_receive_msg_message) {
    set_has_start_receive_msg_message();
    payload_.start_receive_msg_message_ = start_receive_msg_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageWrapper.start_receive_msg_message)
}
inline ::message::StartReceiveMsgMessage* MessageWrapper::_internal_mutable_start_receive_msg_message() {
  if (!_internal_has_start_receive_msg_message()) {
    clear_payload();
    set_has_start_receive_msg_message();
    payload_.start_receive_msg_message_ = CreateMaybeMessage< ::message::StartReceiveMsgMessage >(GetArenaForAllocation());
  }
  return payload_.start_receive_msg_message_;
}
inline ::message::StartReceiveMsgMessage* MessageWrapper::mutable_start_receive_msg_message() {
  ::message::StartReceiveMsgMessage* _msg = _internal_mutable_start_receive_msg_message();
  // @@protoc_insertion_point(field_mutable:message.MessageWrapper.start_receive_msg_message)
  return _msg;
}

// .message.PlayerBasicMessage player_basic_message = 5;
inline bool MessageWrapper::_internal_has_player_basic_message() const {
  return payload_case() == kPlayerBasicMessage;
}
inline bool MessageWrapper::has_player_basic_message() const {
  return _internal_has_player_basic_message();
}
inline void MessageWrapper::set_has_player_basic_message() {
  _oneof_case_[0] = kPlayerBasicMessage;
}
inline void MessageWrapper::clear_player_basic_message() {
  if (_internal_has_player_basic_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.player_basic_message_;
    }
    clear_has_payload();
  }
}
inline ::message::PlayerBasicMessage* MessageWrapper::release_player_basic_message() {
  // @@protoc_insertion_point(field_release:message.MessageWrapper.player_basic_message)
  if (_internal_has_player_basic_message()) {
    clear_has_payload();
      ::message::PlayerBasicMessage* temp = payload_.player_basic_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.player_basic_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::PlayerBasicMessage& MessageWrapper::_internal_player_basic_message() const {
  return _internal_has_player_basic_message()
      ? *payload_.player_basic_message_
      : reinterpret_cast< ::message::PlayerBasicMessage&>(::message::_PlayerBasicMessage_default_instance_);
}
inline const ::message::PlayerBasicMessage& MessageWrapper::player_basic_message() const {
  // @@protoc_insertion_point(field_get:message.MessageWrapper.player_basic_message)
  return _internal_player_basic_message();
}
inline ::message::PlayerBasicMessage* MessageWrapper::unsafe_arena_release_player_basic_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageWrapper.player_basic_message)
  if (_internal_has_player_basic_message()) {
    clear_has_payload();
    ::message::PlayerBasicMessage* temp = payload_.player_basic_message_;
    payload_.player_basic_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageWrapper::unsafe_arena_set_allocated_player_basic_message(::message::PlayerBasicMessage* player_basic_message) {
  clear_payload();
  if (player_basic_message) {
    set_has_player_basic_message();
    payload_.player_basic_message_ = player_basic_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageWrapper.player_basic_message)
}
inline ::message::PlayerBasicMessage* MessageWrapper::_internal_mutable_player_basic_message() {
  if (!_internal_has_player_basic_message()) {
    clear_payload();
    set_has_player_basic_message();
    payload_.player_basic_message_ = CreateMaybeMessage< ::message::PlayerBasicMessage >(GetArenaForAllocation());
  }
  return payload_.player_basic_message_;
}
inline ::message::PlayerBasicMessage* MessageWrapper::mutable_player_basic_message() {
  ::message::PlayerBasicMessage* _msg = _internal_mutable_player_basic_message();
  // @@protoc_insertion_point(field_mutable:message.MessageWrapper.player_basic_message)
  return _msg;
}

// .message.PropTryGetMessage prop_try_get_message = 6;
inline bool MessageWrapper::_internal_has_prop_try_get_message() const {
  return payload_case() == kPropTryGetMessage;
}
inline bool MessageWrapper::has_prop_try_get_message() const {
  return _internal_has_prop_try_get_message();
}
inline void MessageWrapper::set_has_prop_try_get_message() {
  _oneof_case_[0] = kPropTryGetMessage;
}
inline void MessageWrapper::clear_prop_try_get_message() {
  if (_internal_has_prop_try_get_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.prop_try_get_message_;
    }
    clear_has_payload();
  }
}
inline ::message::PropTryGetMessage* MessageWrapper::release_prop_try_get_message() {
  // @@protoc_insertion_point(field_release:message.MessageWrapper.prop_try_get_message)
  if (_internal_has_prop_try_get_message()) {
    clear_has_payload();
      ::message::PropTryGetMessage* temp = payload_.prop_try_get_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.prop_try_get_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::PropTryGetMessage& MessageWrapper::_internal_prop_try_get_message() const {
  return _internal_has_prop_try_get_message()
      ? *payload_.prop_try_get_message_
      : reinterpret_cast< ::message::PropTryGetMessage&>(::message::_PropTryGetMessage_default_instance_);
}
inline const ::message::PropTryGetMessage& MessageWrapper::prop_try_get_message() const {
  // @@protoc_insertion_point(field_get:message.MessageWrapper.prop_try_get_message)
  return _internal_prop_try_get_message();
}
inline ::message::PropTryGetMessage* MessageWrapper::unsafe_arena_release_prop_try_get_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageWrapper.prop_try_get_message)
  if (_internal_has_prop_try_get_message()) {
    clear_has_payload();
    ::message::PropTryGetMessage* temp = payload_.prop_try_get_message_;
    payload_.prop_try_get_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageWrapper::unsafe_arena_set_allocated_prop_try_get_message(::message::PropTryGetMessage* prop_try_get_message) {
  clear_payload();
  if (prop_try_get_message) {
    set_has_prop_try_get_message();
    payload_.prop_try_get_message_ = prop_try_get_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageWrapper.prop_try_get_message)
}
inline ::message::PropTryGetMessage* MessageWrapper::_internal_mutable_prop_try_get_message() {
  if (!_internal_has_prop_try_get_message()) {
    clear_payload();
    set_has_prop_try_get_message();
    payload_.prop_try_get_message_ = CreateMaybeMessage< ::message::PropTryGetMessage >(GetArenaForAllocation());
  }
  return payload_.prop_try_get_message_;
}
inline ::message::PropTryGetMessage* MessageWrapper::mutable_prop_try_get_message() {
  ::message::PropTryGetMessage* _msg = _internal_mutable_prop_try_get_message();
  // @@protoc_insertion_point(field_mutable:message.MessageWrapper.prop_try_get_message)
  return _msg;
}

// .message.PropGetMessage prop_get_message = 7;
inline bool MessageWrapper::_internal_has_prop_get_message() const {
  return payload_case() == kPropGetMessage;
}
inline bool MessageWrapper::has_prop_get_message() const {
  return _internal_has_prop_get_message();
}
inline void MessageWrapper::set_has_prop_get_message() {
  _oneof_case_[0] = kPropGetMessage;
}
inline void MessageWrapper::clear_prop_get_message() {
  if (_internal_has_prop_get_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.prop_get_message_;
    }
    clear_has_payload();
  }
}
inline ::message::PropGetMessage* MessageWrapper::release_prop_get_message() {
  // @@protoc_insertion_point(field_release:message.MessageWrapper.prop_get_message)
  if (_internal_has_prop_get_message()) {
    clear_has_payload();
      ::message::PropGetMessage* temp = payload_.prop_get_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.prop_get_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::PropGetMessage& MessageWrapper::_internal_prop_get_message() const {
  return _internal_has_prop_get_message()
      ? *payload_.prop_get_message_
      : reinterpret_cast< ::message::PropGetMessage&>(::message::_PropGetMessage_default_instance_);
}
inline const ::message::PropGetMessage& MessageWrapper::prop_get_message() const {
  // @@protoc_insertion_point(field_get:message.MessageWrapper.prop_get_message)
  return _internal_prop_get_message();
}
inline ::message::PropGetMessage* MessageWrapper::unsafe_arena_release_prop_get_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageWrapper.prop_get_message)
  if (_internal_has_prop_get_message()) {
    clear_has_payload();
    ::message::PropGetMessage* temp = payload_.prop_get_message_;
    payload_.prop_get_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageWrapper::unsafe_arena_set_allocated_prop_get_message(::message::PropGetMessage* prop_get_message) {
  clear_payload();
  if (prop_get_message) {
    set_has_prop_get_message();
    payload_.prop_get_message_ = prop_get_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageWrapper.prop_get_message)
}
inline ::message::PropGetMessage* MessageWrapper::_internal_mutable_prop_get_message() {
  if (!_internal_has_prop_get_message()) {
    clear_payload();
    set_has_prop_get_message();
    payload_.prop_get_message_ = CreateMaybeMessage< ::message::PropGetMessage >(GetArenaForAllocation());
  }
  return payload_.prop_get_message_;
}
inline ::message::PropGetMessage* MessageWrapper::mutable_prop_get_message() {
  ::message::PropGetMessage* _msg = _internal_mutable_prop_get_message();
  // @@protoc_insertion_point(field_mutable:message.MessageWrapper.prop_get_message)
  return _msg;
}

// .message.IntegerMessage integer_message = 8;
inline bool MessageWrapper::_internal_has_integer_message() const {
  return payload_case() == kIntegerMessage;
}
inline bool MessageWrapper::has_integer_message() const {
  return _internal_has_integer_message();
}
inline void MessageWrapper::set_has_integer_message() {
  _oneof_case_[0] = kIntegerMessage;
}
inline void MessageWrapper::clear_integer_message() {
  if (_internal_has_integer_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.integer_message_;
    }
    clear_has_payload();
  }
}
inline ::message::IntegerMessage* MessageWrapper::release_integer_message() {
  // @@protoc_insertion_point(field_release:message.MessageWrapper.integer_message)
  if (_internal_has_integer_message()) {
    clear_has_payload();
      ::message::IntegerMessage* temp = payload_.integer_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.integer_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::IntegerMessage& MessageWrapper::_internal_integer_message() const {
  return _internal_has_integer_message()
      ? *payload_.integer_message_
      : reinterpret_cast< ::message::IntegerMessage&>(::message::_IntegerMessage_default_instance_);
}
inline const ::message::IntegerMessage& MessageWrapper::integer_message() const {
  // @@protoc_insertion_point(field_get:message.MessageWrapper.integer_message)
  return _internal_integer_message();
}
inline ::message::IntegerMessage* MessageWrapper::unsafe_arena_release_integer_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageWrapper.integer_message)
  if (_internal_has_integer_message()) {
    clear_has_payload();
    ::message::IntegerMessage* temp = payload_.integer_message_;
    payload_.integer_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageWrapper::unsafe_arena_set_allocated_integer_message(::message::IntegerMessage* integer_message) {
  clear_payload();
  if (integer_message) {
    set_has_integer_message();
    payload_.integer_message_ = integer_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageWrapper.integer_message)
}
inline ::message::IntegerMessage* MessageWrapper::_internal_mutable_integer_message() {
  if (!_internal_has_integer_message()) {
    clear_payload();
    set_has_integer_message();
    payload_.integer_message_ = CreateMaybeMessage< ::message::IntegerMessage >(GetArenaForAllocation());
  }
  return payload_.integer_message_;
}
inline ::message::IntegerMessage* MessageWrapper::mutable_integer_message() {
  ::message::IntegerMessage* _msg = _internal_mutable_integer_message();
  // @@protoc_insertion_point(field_mutable:message.MessageWrapper.integer_message)
  return _msg;
}

// .message.GateMessage gate_message = 9;
inline bool MessageWrapper::_internal_has_gate_message() const {
  return payload_case() == kGateMessage;
}
inline bool MessageWrapper::has_gate_message() const {
  return _internal_has_gate_message();
}
inline void MessageWrapper::set_has_gate_message() {
  _oneof_case_[0] = kGateMessage;
}
inline void MessageWrapper::clear_gate_message() {
  if (_internal_has_gate_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.gate_message_;
    }
    clear_has_payload();
  }
}
inline ::message::GateMessage* MessageWrapper::release_gate_message() {
  // @@protoc_insertion_point(field_release:message.MessageWrapper.gate_message)
  if (_internal_has_gate_message()) {
    clear_has_payload();
      ::message::GateMessage* temp = payload_.gate_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.gate_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::GateMessage& MessageWrapper::_internal_gate_message() const {
  return _internal_has_gate_message()
      ? *payload_.gate_message_
      : reinterpret_cast< ::message::GateMessage&>(::message::_GateMessage_default_instance_);
}
inline const ::message::GateMessage& MessageWrapper::gate_message() const {
  // @@protoc_insertion_point(field_get:message.MessageWrapper.gate_message)
  return _internal_gate_message();
}
inline ::message::GateMessage* MessageWrapper::unsafe_arena_release_gate_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageWrapper.gate_message)
  if (_internal_has_gate_message()) {
    clear_has_payload();
    ::message::GateMessage* temp = payload_.gate_message_;
    payload_.gate_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageWrapper::unsafe_arena_set_allocated_gate_message(::message::GateMessage* gate_message) {
  clear_payload();
  if (gate_message) {
    set_has_gate_message();
    payload_.gate_message_ = gate_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageWrapper.gate_message)
}
inline ::message::GateMessage* MessageWrapper::_internal_mutable_gate_message() {
  if (!_internal_has_gate_message()) {
    clear_payload();
    set_has_gate_message();
    payload_.gate_message_ = CreateMaybeMessage< ::message::GateMessage >(GetArenaForAllocation());
  }
  return payload_.gate_message_;
}
inline ::message::GateMessage* MessageWrapper::mutable_gate_message() {
  ::message::GateMessage* _msg = _internal_mutable_gate_message();
  // @@protoc_insertion_point(field_mutable:message.MessageWrapper.gate_message)
  return _msg;
}

// .message.EnterGateMessage enter_gate_message = 10;
inline bool MessageWrapper::_internal_has_enter_gate_message() const {
  return payload_case() == kEnterGateMessage;
}
inline bool MessageWrapper::has_enter_gate_message() const {
  return _internal_has_enter_gate_message();
}
inline void MessageWrapper::set_has_enter_gate_message() {
  _oneof_case_[0] = kEnterGateMessage;
}
inline void MessageWrapper::clear_enter_gate_message() {
  if (_internal_has_enter_gate_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.enter_gate_message_;
    }
    clear_has_payload();
  }
}
inline ::message::EnterGateMessage* MessageWrapper::release_enter_gate_message() {
  // @@protoc_insertion_point(field_release:message.MessageWrapper.enter_gate_message)
  if (_internal_has_enter_gate_message()) {
    clear_has_payload();
      ::message::EnterGateMessage* temp = payload_.enter_gate_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.enter_gate_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::EnterGateMessage& MessageWrapper::_internal_enter_gate_message() const {
  return _internal_has_enter_gate_message()
      ? *payload_.enter_gate_message_
      : reinterpret_cast< ::message::EnterGateMessage&>(::message::_EnterGateMessage_default_instance_);
}
inline const ::message::EnterGateMessage& MessageWrapper::enter_gate_message() const {
  // @@protoc_insertion_point(field_get:message.MessageWrapper.enter_gate_message)
  return _internal_enter_gate_message();
}
inline ::message::EnterGateMessage* MessageWrapper::unsafe_arena_release_enter_gate_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageWrapper.enter_gate_message)
  if (_internal_has_enter_gate_message()) {
    clear_has_payload();
    ::message::EnterGateMessage* temp = payload_.enter_gate_message_;
    payload_.enter_gate_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageWrapper::unsafe_arena_set_allocated_enter_gate_message(::message::EnterGateMessage* enter_gate_message) {
  clear_payload();
  if (enter_gate_message) {
    set_has_enter_gate_message();
    payload_.enter_gate_message_ = enter_gate_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageWrapper.enter_gate_message)
}
inline ::message::EnterGateMessage* MessageWrapper::_internal_mutable_enter_gate_message() {
  if (!_internal_has_enter_gate_message()) {
    clear_payload();
    set_has_enter_gate_message();
    payload_.enter_gate_message_ = CreateMaybeMessage< ::message::EnterGateMessage >(GetArenaForAllocation());
  }
  return payload_.enter_gate_message_;
}
inline ::message::EnterGateMessage* MessageWrapper::mutable_enter_gate_message() {
  ::message::EnterGateMessage* _msg = _internal_mutable_enter_gate_message();
  // @@protoc_insertion_point(field_mutable:message.MessageWrapper.enter_gate_message)
  return _msg;
}

// .message.EnterGateResultMessage enter_gate_result_message = 11;
inline bool MessageWrapper::_internal_has_enter_gate_result_message() const {
  return payload_case() == kEnterGateResultMessage;
}
inline bool MessageWrapper::has_enter_gate_result_message() const {
  return _internal_has_enter_gate_result_message();
}
inline void MessageWrapper::set_has_enter_gate_result_message() {
  _oneof_case_[0] = kEnterGateResultMessage;
}
inline void MessageWrapper::clear_enter_gate_result_message() {
  if (_internal_has_enter_gate_result_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.enter_gate_result_message_;
    }
    clear_has_payload();
  }
}
inline ::message::EnterGateResultMessage* MessageWrapper::release_enter_gate_result_message() {
  // @@protoc_insertion_point(field_release:message.MessageWrapper.enter_gate_result_message)
  if (_internal_has_enter_gate_result_message()) {
    clear_has_payload();
      ::message::EnterGateResultMessage* temp = payload_.enter_gate_result_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.enter_gate_result_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::EnterGateResultMessage& MessageWrapper::_internal_enter_gate_result_message() const {
  return _internal_has_enter_gate_result_message()
      ? *payload_.enter_gate_result_message_
      : reinterpret_cast< ::message::EnterGateResultMessage&>(::message::_EnterGateResultMessage_default_instance_);
}
inline const ::message::EnterGateResultMessage& MessageWrapper::enter_gate_result_message() const {
  // @@protoc_insertion_point(field_get:message.MessageWrapper.enter_gate_result_message)
  return _internal_enter_gate_result_message();
}
inline ::message::EnterGateResultMessage* MessageWrapper::unsafe_arena_release_enter_gate_result_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageWrapper.enter_gate_result_message)
  if (_internal_has_enter_gate_result_message()) {
    clear_has_payload();
    ::message::EnterGateResultMessage* temp = payload_.enter_gate_result_message_;
    payload_.enter_gate_result_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageWrapper::unsafe_arena_set_allocated_enter_gate_result_message(::message::EnterGateResultMessage* enter_gate_result_message) {
  clear_payload();
  if (enter_gate_result_message) {
    set_has_enter_gate_result_message();
    payload_.enter_gate_result_message_ = enter_gate_result_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageWrapper.enter_gate_result_message)
}
inline ::message::EnterGateResultMessage* MessageWrapper::_internal_mutable_enter_gate_result_message() {
  if (!_internal_has_enter_gate_result_message()) {
    clear_payload();
    set_has_enter_gate_result_message();
    payload_.enter_gate_result_message_ = CreateMaybeMessage< ::message::EnterGateResultMessage >(GetArenaForAllocation());
  }
  return payload_.enter_gate_result_message_;
}
inline ::message::EnterGateResultMessage* MessageWrapper::mutable_enter_gate_result_message() {
  ::message::EnterGateResultMessage* _msg = _internal_mutable_enter_gate_result_message();
  // @@protoc_insertion_point(field_mutable:message.MessageWrapper.enter_gate_result_message)
  return _msg;
}

inline bool MessageWrapper::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void MessageWrapper::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline MessageWrapper::PayloadCase MessageWrapper::payload_case() const {
  return MessageWrapper::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RoomMessage

// bool is_join = 1;
inline void RoomMessage::clear_is_join() {
  is_join_ = false;
}
inline bool RoomMessage::_internal_is_join() const {
  return is_join_;
}
inline bool RoomMessage::is_join() const {
  // @@protoc_insertion_point(field_get:message.RoomMessage.is_join)
  return _internal_is_join();
}
inline void RoomMessage::_internal_set_is_join(bool value) {
  
  is_join_ = value;
}
inline void RoomMessage::set_is_join(bool value) {
  _internal_set_is_join(value);
  // @@protoc_insertion_point(field_set:message.RoomMessage.is_join)
}

// int32 room_id = 2;
inline void RoomMessage::clear_room_id() {
  room_id_ = 0;
}
inline int32_t RoomMessage::_internal_room_id() const {
  return room_id_;
}
inline int32_t RoomMessage::room_id() const {
  // @@protoc_insertion_point(field_get:message.RoomMessage.room_id)
  return _internal_room_id();
}
inline void RoomMessage::_internal_set_room_id(int32_t value) {
  
  room_id_ = value;
}
inline void RoomMessage::set_room_id(int32_t value) {
  _internal_set_room_id(value);
  // @@protoc_insertion_point(field_set:message.RoomMessage.room_id)
}

// int32 player_id = 3;
inline void RoomMessage::clear_player_id() {
  player_id_ = 0;
}
inline int32_t RoomMessage::_internal_player_id() const {
  return player_id_;
}
inline int32_t RoomMessage::player_id() const {
  // @@protoc_insertion_point(field_get:message.RoomMessage.player_id)
  return _internal_player_id();
}
inline void RoomMessage::_internal_set_player_id(int32_t value) {
  
  player_id_ = value;
}
inline void RoomMessage::set_player_id(int32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:message.RoomMessage.player_id)
}

// repeated .message.Character characters = 4;
inline int RoomMessage::_internal_characters_size() const {
  return characters_.size();
}
inline int RoomMessage::characters_size() const {
  return _internal_characters_size();
}
inline void RoomMessage::clear_characters() {
  characters_.Clear();
}
inline ::message::Character* RoomMessage::mutable_characters(int index) {
  // @@protoc_insertion_point(field_mutable:message.RoomMessage.characters)
  return characters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::Character >*
RoomMessage::mutable_characters() {
  // @@protoc_insertion_point(field_mutable_list:message.RoomMessage.characters)
  return &characters_;
}
inline const ::message::Character& RoomMessage::_internal_characters(int index) const {
  return characters_.Get(index);
}
inline const ::message::Character& RoomMessage::characters(int index) const {
  // @@protoc_insertion_point(field_get:message.RoomMessage.characters)
  return _internal_characters(index);
}
inline ::message::Character* RoomMessage::_internal_add_characters() {
  return characters_.Add();
}
inline ::message::Character* RoomMessage::add_characters() {
  ::message::Character* _add = _internal_add_characters();
  // @@protoc_insertion_point(field_add:message.RoomMessage.characters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::Character >&
RoomMessage::characters() const {
  // @@protoc_insertion_point(field_list:message.RoomMessage.characters)
  return characters_;
}

// -------------------------------------------------------------------

// StringMessage

// int32 message_type = 1;
inline void StringMessage::clear_message_type() {
  message_type_ = 0;
}
inline int32_t StringMessage::_internal_message_type() const {
  return message_type_;
}
inline int32_t StringMessage::message_type() const {
  // @@protoc_insertion_point(field_get:message.StringMessage.message_type)
  return _internal_message_type();
}
inline void StringMessage::_internal_set_message_type(int32_t value) {
  
  message_type_ = value;
}
inline void StringMessage::set_message_type(int32_t value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:message.StringMessage.message_type)
}

// string message_content = 2;
inline void StringMessage::clear_message_content() {
  message_content_.ClearToEmpty();
}
inline const std::string& StringMessage::message_content() const {
  // @@protoc_insertion_point(field_get:message.StringMessage.message_content)
  return _internal_message_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StringMessage::set_message_content(ArgT0&& arg0, ArgT... args) {
 
 message_content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:message.StringMessage.message_content)
}
inline std::string* StringMessage::mutable_message_content() {
  std::string* _s = _internal_mutable_message_content();
  // @@protoc_insertion_point(field_mutable:message.StringMessage.message_content)
  return _s;
}
inline const std::string& StringMessage::_internal_message_content() const {
  return message_content_.Get();
}
inline void StringMessage::_internal_set_message_content(const std::string& value) {
  
  message_content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StringMessage::_internal_mutable_message_content() {
  
  return message_content_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StringMessage::release_message_content() {
  // @@protoc_insertion_point(field_release:message.StringMessage.message_content)
  return message_content_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StringMessage::set_allocated_message_content(std::string* message_content) {
  if (message_content != nullptr) {
    
  } else {
    
  }
  message_content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message_content,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_content_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.StringMessage.message_content)
}

// -------------------------------------------------------------------

// LobbyMessage

// bool is_ready = 1;
inline void LobbyMessage::clear_is_ready() {
  is_ready_ = false;
}
inline bool LobbyMessage::_internal_is_ready() const {
  return is_ready_;
}
inline bool LobbyMessage::is_ready() const {
  // @@protoc_insertion_point(field_get:message.LobbyMessage.is_ready)
  return _internal_is_ready();
}
inline void LobbyMessage::_internal_set_is_ready(bool value) {
  
  is_ready_ = value;
}
inline void LobbyMessage::set_is_ready(bool value) {
  _internal_set_is_ready(value);
  // @@protoc_insertion_point(field_set:message.LobbyMessage.is_ready)
}

// int32 player_id = 2;
inline void LobbyMessage::clear_player_id() {
  player_id_ = 0;
}
inline int32_t LobbyMessage::_internal_player_id() const {
  return player_id_;
}
inline int32_t LobbyMessage::player_id() const {
  // @@protoc_insertion_point(field_get:message.LobbyMessage.player_id)
  return _internal_player_id();
}
inline void LobbyMessage::_internal_set_player_id(int32_t value) {
  
  player_id_ = value;
}
inline void LobbyMessage::set_player_id(int32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:message.LobbyMessage.player_id)
}

// .message.CharacterType character_type = 3;
inline void LobbyMessage::clear_character_type() {
  character_type_ = 0;
}
inline ::message::CharacterType LobbyMessage::_internal_character_type() const {
  return static_cast< ::message::CharacterType >(character_type_);
}
inline ::message::CharacterType LobbyMessage::character_type() const {
  // @@protoc_insertion_point(field_get:message.LobbyMessage.character_type)
  return _internal_character_type();
}
inline void LobbyMessage::_internal_set_character_type(::message::CharacterType value) {
  
  character_type_ = value;
}
inline void LobbyMessage::set_character_type(::message::CharacterType value) {
  _internal_set_character_type(value);
  // @@protoc_insertion_point(field_set:message.LobbyMessage.character_type)
}

// -------------------------------------------------------------------

// StartReceiveMsgMessage

// int32 player_id = 1;
inline void StartReceiveMsgMessage::clear_player_id() {
  player_id_ = 0;
}
inline int32_t StartReceiveMsgMessage::_internal_player_id() const {
  return player_id_;
}
inline int32_t StartReceiveMsgMessage::player_id() const {
  // @@protoc_insertion_point(field_get:message.StartReceiveMsgMessage.player_id)
  return _internal_player_id();
}
inline void StartReceiveMsgMessage::_internal_set_player_id(int32_t value) {
  
  player_id_ = value;
}
inline void StartReceiveMsgMessage::set_player_id(int32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:message.StartReceiveMsgMessage.player_id)
}

// -------------------------------------------------------------------

// PlayerBasicMessage

// int32 player_id = 1;
inline void PlayerBasicMessage::clear_player_id() {
  player_id_ = 0;
}
inline int32_t PlayerBasicMessage::_internal_player_id() const {
  return player_id_;
}
inline int32_t PlayerBasicMessage::player_id() const {
  // @@protoc_insertion_point(field_get:message.PlayerBasicMessage.player_id)
  return _internal_player_id();
}
inline void PlayerBasicMessage::_internal_set_player_id(int32_t value) {
  
  player_id_ = value;
}
inline void PlayerBasicMessage::set_player_id(int32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:message.PlayerBasicMessage.player_id)
}

// float position_x = 2;
inline void PlayerBasicMessage::clear_position_x() {
  position_x_ = 0;
}
inline float PlayerBasicMessage::_internal_position_x() const {
  return position_x_;
}
inline float PlayerBasicMessage::position_x() const {
  // @@protoc_insertion_point(field_get:message.PlayerBasicMessage.position_x)
  return _internal_position_x();
}
inline void PlayerBasicMessage::_internal_set_position_x(float value) {
  
  position_x_ = value;
}
inline void PlayerBasicMessage::set_position_x(float value) {
  _internal_set_position_x(value);
  // @@protoc_insertion_point(field_set:message.PlayerBasicMessage.position_x)
}

// float position_y = 3;
inline void PlayerBasicMessage::clear_position_y() {
  position_y_ = 0;
}
inline float PlayerBasicMessage::_internal_position_y() const {
  return position_y_;
}
inline float PlayerBasicMessage::position_y() const {
  // @@protoc_insertion_point(field_get:message.PlayerBasicMessage.position_y)
  return _internal_position_y();
}
inline void PlayerBasicMessage::_internal_set_position_y(float value) {
  
  position_y_ = value;
}
inline void PlayerBasicMessage::set_position_y(float value) {
  _internal_set_position_y(value);
  // @@protoc_insertion_point(field_set:message.PlayerBasicMessage.position_y)
}

// float hp = 4;
inline void PlayerBasicMessage::clear_hp() {
  hp_ = 0;
}
inline float PlayerBasicMessage::_internal_hp() const {
  return hp_;
}
inline float PlayerBasicMessage::hp() const {
  // @@protoc_insertion_point(field_get:message.PlayerBasicMessage.hp)
  return _internal_hp();
}
inline void PlayerBasicMessage::_internal_set_hp(float value) {
  
  hp_ = value;
}
inline void PlayerBasicMessage::set_hp(float value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:message.PlayerBasicMessage.hp)
}

// float max_hp = 5;
inline void PlayerBasicMessage::clear_max_hp() {
  max_hp_ = 0;
}
inline float PlayerBasicMessage::_internal_max_hp() const {
  return max_hp_;
}
inline float PlayerBasicMessage::max_hp() const {
  // @@protoc_insertion_point(field_get:message.PlayerBasicMessage.max_hp)
  return _internal_max_hp();
}
inline void PlayerBasicMessage::_internal_set_max_hp(float value) {
  
  max_hp_ = value;
}
inline void PlayerBasicMessage::set_max_hp(float value) {
  _internal_set_max_hp(value);
  // @@protoc_insertion_point(field_set:message.PlayerBasicMessage.max_hp)
}

// .message.PlayerAnimationType animation_type = 6;
inline void PlayerBasicMessage::clear_animation_type() {
  animation_type_ = 0;
}
inline ::message::PlayerAnimationType PlayerBasicMessage::_internal_animation_type() const {
  return static_cast< ::message::PlayerAnimationType >(animation_type_);
}
inline ::message::PlayerAnimationType PlayerBasicMessage::animation_type() const {
  // @@protoc_insertion_point(field_get:message.PlayerBasicMessage.animation_type)
  return _internal_animation_type();
}
inline void PlayerBasicMessage::_internal_set_animation_type(::message::PlayerAnimationType value) {
  
  animation_type_ = value;
}
inline void PlayerBasicMessage::set_animation_type(::message::PlayerAnimationType value) {
  _internal_set_animation_type(value);
  // @@protoc_insertion_point(field_set:message.PlayerBasicMessage.animation_type)
}

// .message.CharacterState character_state = 7;
inline void PlayerBasicMessage::clear_character_state() {
  character_state_ = 0;
}
inline ::message::CharacterState PlayerBasicMessage::_internal_character_state() const {
  return static_cast< ::message::CharacterState >(character_state_);
}
inline ::message::CharacterState PlayerBasicMessage::character_state() const {
  // @@protoc_insertion_point(field_get:message.PlayerBasicMessage.character_state)
  return _internal_character_state();
}
inline void PlayerBasicMessage::_internal_set_character_state(::message::CharacterState value) {
  
  character_state_ = value;
}
inline void PlayerBasicMessage::set_character_state(::message::CharacterState value) {
  _internal_set_character_state(value);
  // @@protoc_insertion_point(field_set:message.PlayerBasicMessage.character_state)
}

// -------------------------------------------------------------------

// PropTryGetMessage

// int32 player_id = 1;
inline void PropTryGetMessage::clear_player_id() {
  player_id_ = 0;
}
inline int32_t PropTryGetMessage::_internal_player_id() const {
  return player_id_;
}
inline int32_t PropTryGetMessage::player_id() const {
  // @@protoc_insertion_point(field_get:message.PropTryGetMessage.player_id)
  return _internal_player_id();
}
inline void PropTryGetMessage::_internal_set_player_id(int32_t value) {
  
  player_id_ = value;
}
inline void PropTryGetMessage::set_player_id(int32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:message.PropTryGetMessage.player_id)
}

// int32 prop_id = 2;
inline void PropTryGetMessage::clear_prop_id() {
  prop_id_ = 0;
}
inline int32_t PropTryGetMessage::_internal_prop_id() const {
  return prop_id_;
}
inline int32_t PropTryGetMessage::prop_id() const {
  // @@protoc_insertion_point(field_get:message.PropTryGetMessage.prop_id)
  return _internal_prop_id();
}
inline void PropTryGetMessage::_internal_set_prop_id(int32_t value) {
  
  prop_id_ = value;
}
inline void PropTryGetMessage::set_prop_id(int32_t value) {
  _internal_set_prop_id(value);
  // @@protoc_insertion_point(field_set:message.PropTryGetMessage.prop_id)
}

// int32 prop_type = 3;
inline void PropTryGetMessage::clear_prop_type() {
  prop_type_ = 0;
}
inline int32_t PropTryGetMessage::_internal_prop_type() const {
  return prop_type_;
}
inline int32_t PropTryGetMessage::prop_type() const {
  // @@protoc_insertion_point(field_get:message.PropTryGetMessage.prop_type)
  return _internal_prop_type();
}
inline void PropTryGetMessage::_internal_set_prop_type(int32_t value) {
  
  prop_type_ = value;
}
inline void PropTryGetMessage::set_prop_type(int32_t value) {
  _internal_set_prop_type(value);
  // @@protoc_insertion_point(field_set:message.PropTryGetMessage.prop_type)
}

// -------------------------------------------------------------------

// PropGetMessage

// bool is_get = 1;
inline void PropGetMessage::clear_is_get() {
  is_get_ = false;
}
inline bool PropGetMessage::_internal_is_get() const {
  return is_get_;
}
inline bool PropGetMessage::is_get() const {
  // @@protoc_insertion_point(field_get:message.PropGetMessage.is_get)
  return _internal_is_get();
}
inline void PropGetMessage::_internal_set_is_get(bool value) {
  
  is_get_ = value;
}
inline void PropGetMessage::set_is_get(bool value) {
  _internal_set_is_get(value);
  // @@protoc_insertion_point(field_set:message.PropGetMessage.is_get)
}

// int32 player_id = 2;
inline void PropGetMessage::clear_player_id() {
  player_id_ = 0;
}
inline int32_t PropGetMessage::_internal_player_id() const {
  return player_id_;
}
inline int32_t PropGetMessage::player_id() const {
  // @@protoc_insertion_point(field_get:message.PropGetMessage.player_id)
  return _internal_player_id();
}
inline void PropGetMessage::_internal_set_player_id(int32_t value) {
  
  player_id_ = value;
}
inline void PropGetMessage::set_player_id(int32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:message.PropGetMessage.player_id)
}

// int32 prop_id = 3;
inline void PropGetMessage::clear_prop_id() {
  prop_id_ = 0;
}
inline int32_t PropGetMessage::_internal_prop_id() const {
  return prop_id_;
}
inline int32_t PropGetMessage::prop_id() const {
  // @@protoc_insertion_point(field_get:message.PropGetMessage.prop_id)
  return _internal_prop_id();
}
inline void PropGetMessage::_internal_set_prop_id(int32_t value) {
  
  prop_id_ = value;
}
inline void PropGetMessage::set_prop_id(int32_t value) {
  _internal_set_prop_id(value);
  // @@protoc_insertion_point(field_set:message.PropGetMessage.prop_id)
}

// -------------------------------------------------------------------

// IntegerMessage

// .message.IntegerMessageType message_type = 1;
inline void IntegerMessage::clear_message_type() {
  message_type_ = 0;
}
inline ::message::IntegerMessageType IntegerMessage::_internal_message_type() const {
  return static_cast< ::message::IntegerMessageType >(message_type_);
}
inline ::message::IntegerMessageType IntegerMessage::message_type() const {
  // @@protoc_insertion_point(field_get:message.IntegerMessage.message_type)
  return _internal_message_type();
}
inline void IntegerMessage::_internal_set_message_type(::message::IntegerMessageType value) {
  
  message_type_ = value;
}
inline void IntegerMessage::set_message_type(::message::IntegerMessageType value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:message.IntegerMessage.message_type)
}

// int32 value = 2;
inline void IntegerMessage::clear_value() {
  value_ = 0;
}
inline int32_t IntegerMessage::_internal_value() const {
  return value_;
}
inline int32_t IntegerMessage::value() const {
  // @@protoc_insertion_point(field_get:message.IntegerMessage.value)
  return _internal_value();
}
inline void IntegerMessage::_internal_set_value(int32_t value) {
  
  value_ = value;
}
inline void IntegerMessage::set_value(int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:message.IntegerMessage.value)
}

// -------------------------------------------------------------------

// Gate

// .message.GateDirection gate_direction = 1;
inline void Gate::clear_gate_direction() {
  gate_direction_ = 0;
}
inline ::message::GateDirection Gate::_internal_gate_direction() const {
  return static_cast< ::message::GateDirection >(gate_direction_);
}
inline ::message::GateDirection Gate::gate_direction() const {
  // @@protoc_insertion_point(field_get:message.Gate.gate_direction)
  return _internal_gate_direction();
}
inline void Gate::_internal_set_gate_direction(::message::GateDirection value) {
  
  gate_direction_ = value;
}
inline void Gate::set_gate_direction(::message::GateDirection value) {
  _internal_set_gate_direction(value);
  // @@protoc_insertion_point(field_set:message.Gate.gate_direction)
}

// .message.GateType gate_type = 2;
inline void Gate::clear_gate_type() {
  gate_type_ = 0;
}
inline ::message::GateType Gate::_internal_gate_type() const {
  return static_cast< ::message::GateType >(gate_type_);
}
inline ::message::GateType Gate::gate_type() const {
  // @@protoc_insertion_point(field_get:message.Gate.gate_type)
  return _internal_gate_type();
}
inline void Gate::_internal_set_gate_type(::message::GateType value) {
  
  gate_type_ = value;
}
inline void Gate::set_gate_type(::message::GateType value) {
  _internal_set_gate_type(value);
  // @@protoc_insertion_point(field_set:message.Gate.gate_type)
}

// -------------------------------------------------------------------

// GateMessage

// repeated .message.Gate gates = 1;
inline int GateMessage::_internal_gates_size() const {
  return gates_.size();
}
inline int GateMessage::gates_size() const {
  return _internal_gates_size();
}
inline void GateMessage::clear_gates() {
  gates_.Clear();
}
inline ::message::Gate* GateMessage::mutable_gates(int index) {
  // @@protoc_insertion_point(field_mutable:message.GateMessage.gates)
  return gates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::Gate >*
GateMessage::mutable_gates() {
  // @@protoc_insertion_point(field_mutable_list:message.GateMessage.gates)
  return &gates_;
}
inline const ::message::Gate& GateMessage::_internal_gates(int index) const {
  return gates_.Get(index);
}
inline const ::message::Gate& GateMessage::gates(int index) const {
  // @@protoc_insertion_point(field_get:message.GateMessage.gates)
  return _internal_gates(index);
}
inline ::message::Gate* GateMessage::_internal_add_gates() {
  return gates_.Add();
}
inline ::message::Gate* GateMessage::add_gates() {
  ::message::Gate* _add = _internal_add_gates();
  // @@protoc_insertion_point(field_add:message.GateMessage.gates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::Gate >&
GateMessage::gates() const {
  // @@protoc_insertion_point(field_list:message.GateMessage.gates)
  return gates_;
}

// -------------------------------------------------------------------

// EnterGateMessage

// .message.GateDirection gate_direction = 2;
inline void EnterGateMessage::clear_gate_direction() {
  gate_direction_ = 0;
}
inline ::message::GateDirection EnterGateMessage::_internal_gate_direction() const {
  return static_cast< ::message::GateDirection >(gate_direction_);
}
inline ::message::GateDirection EnterGateMessage::gate_direction() const {
  // @@protoc_insertion_point(field_get:message.EnterGateMessage.gate_direction)
  return _internal_gate_direction();
}
inline void EnterGateMessage::_internal_set_gate_direction(::message::GateDirection value) {
  
  gate_direction_ = value;
}
inline void EnterGateMessage::set_gate_direction(::message::GateDirection value) {
  _internal_set_gate_direction(value);
  // @@protoc_insertion_point(field_set:message.EnterGateMessage.gate_direction)
}

// -------------------------------------------------------------------

// EnterGateResultMessage

// int32 player_id = 1;
inline void EnterGateResultMessage::clear_player_id() {
  player_id_ = 0;
}
inline int32_t EnterGateResultMessage::_internal_player_id() const {
  return player_id_;
}
inline int32_t EnterGateResultMessage::player_id() const {
  // @@protoc_insertion_point(field_get:message.EnterGateResultMessage.player_id)
  return _internal_player_id();
}
inline void EnterGateResultMessage::_internal_set_player_id(int32_t value) {
  
  player_id_ = value;
}
inline void EnterGateResultMessage::set_player_id(int32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:message.EnterGateResultMessage.player_id)
}

// .message.Gate gate = 2;
inline bool EnterGateResultMessage::_internal_has_gate() const {
  return this != internal_default_instance() && gate_ != nullptr;
}
inline bool EnterGateResultMessage::has_gate() const {
  return _internal_has_gate();
}
inline void EnterGateResultMessage::clear_gate() {
  if (GetArenaForAllocation() == nullptr && gate_ != nullptr) {
    delete gate_;
  }
  gate_ = nullptr;
}
inline const ::message::Gate& EnterGateResultMessage::_internal_gate() const {
  const ::message::Gate* p = gate_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Gate&>(
      ::message::_Gate_default_instance_);
}
inline const ::message::Gate& EnterGateResultMessage::gate() const {
  // @@protoc_insertion_point(field_get:message.EnterGateResultMessage.gate)
  return _internal_gate();
}
inline void EnterGateResultMessage::unsafe_arena_set_allocated_gate(
    ::message::Gate* gate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gate_);
  }
  gate_ = gate;
  if (gate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.EnterGateResultMessage.gate)
}
inline ::message::Gate* EnterGateResultMessage::release_gate() {
  
  ::message::Gate* temp = gate_;
  gate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::message::Gate* EnterGateResultMessage::unsafe_arena_release_gate() {
  // @@protoc_insertion_point(field_release:message.EnterGateResultMessage.gate)
  
  ::message::Gate* temp = gate_;
  gate_ = nullptr;
  return temp;
}
inline ::message::Gate* EnterGateResultMessage::_internal_mutable_gate() {
  
  if (gate_ == nullptr) {
    auto* p = CreateMaybeMessage<::message::Gate>(GetArenaForAllocation());
    gate_ = p;
  }
  return gate_;
}
inline ::message::Gate* EnterGateResultMessage::mutable_gate() {
  ::message::Gate* _msg = _internal_mutable_gate();
  // @@protoc_insertion_point(field_mutable:message.EnterGateResultMessage.gate)
  return _msg;
}
inline void EnterGateResultMessage::set_allocated_gate(::message::Gate* gate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gate_;
  }
  if (gate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::message::Gate>::GetOwningArena(gate);
    if (message_arena != submessage_arena) {
      gate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gate, submessage_arena);
    }
    
  } else {
    
  }
  gate_ = gate;
  // @@protoc_insertion_point(field_set_allocated:message.EnterGateResultMessage.gate)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace message

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::message::CharacterType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message::CharacterType>() {
  return ::message::CharacterType_descriptor();
}
template <> struct is_proto_enum< ::message::StringMessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message::StringMessageType>() {
  return ::message::StringMessageType_descriptor();
}
template <> struct is_proto_enum< ::message::PlayerAnimationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message::PlayerAnimationType>() {
  return ::message::PlayerAnimationType_descriptor();
}
template <> struct is_proto_enum< ::message::CharacterState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message::CharacterState>() {
  return ::message::CharacterState_descriptor();
}
template <> struct is_proto_enum< ::message::IntegerMessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message::IntegerMessageType>() {
  return ::message::IntegerMessageType_descriptor();
}
template <> struct is_proto_enum< ::message::GateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message::GateType>() {
  return ::message::GateType_descriptor();
}
template <> struct is_proto_enum< ::message::GateDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message::GateDirection>() {
  return ::message::GateDirection_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_message_2eproto
